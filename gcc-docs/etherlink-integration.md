# EtherLink C/C++ Integration Guide

Complete guide for using EtherLink (Ethereum-GhostChain Bridge) from C and C++ projects via C FFI bindings.

## Table of Contents

- [Overview](#overview)
- [Building C Bindings](#building-c-bindings)
- [C Usage](#c-usage)
- [C++ Wrapper](#c-wrapper)
- [CMake Integration](#cmake-integration)
- [Bridge Operations](#bridge-operations)
- [Event Monitoring](#event-monitoring)
- [Error Handling](#error-handling)

## Overview

EtherLink provides C bindings for Ethereum-GhostChain bridge operations, allowing C and C++ applications to facilitate secure asset transfers, monitor bridge events, and manage cross-chain state synchronization. The bindings maintain security and performance while providing familiar APIs for Ethereum integration.

## Building C Bindings

### Rust Library Setup

Configure the Rust project for C-compatible binaries:

```toml
# Cargo.toml
[package]
name = "etherlink-c"
version = "0.1.0"
edition = "2021"

[lib]
name = "etherlink_c"
crate-type = ["cdylib", "staticlib"]

[dependencies]
etherlink = { version = "0.1", features = ["std", "ethereum", "ghostchain"] }
gcrypt = { version = "0.2", features = ["ed25519", "secp256k1", "keccak"] }
web3 = "0.19"
tokio = { version = "1.0", features = ["rt-multi-thread"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
hex = "0.4"
libc = "0.2"

[build-dependencies]
cbindgen = "0.24"
```

### Build Script for Header Generation

```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_dir = PathBuf::from(&crate_dir).join("include");

    std::fs::create_dir_all(&output_dir).unwrap();

    let output_file = output_dir.join("etherlink.h");

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("ETHERLINK_H")
        .with_documentation(true)
        .with_autogen_warning("/* Auto-generated by cbindgen */")
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(output_file);

    println!("cargo:rerun-if-changed=src/lib.rs");
}
```

### C FFI Implementation

```rust
// src/lib.rs
use etherlink::{EtherLink, BridgeConfig, BridgeEvent, DepositRequest, WithdrawalRequest};
use gcrypt::protocols::{Ed25519, Secp256k1};
use web3::types::{Address, U256, H256};
use std::ptr;
use std::slice;
use std::ffi::{c_char, c_int, c_uint, c_void, CStr, CString};
use libc::size_t;
use tokio::runtime::Runtime;
use serde::{Serialize, Deserialize};

// Error codes
pub const ETHERLINK_SUCCESS: c_int = 0;
pub const ETHERLINK_ERROR_INVALID_INPUT: c_int = -1;
pub const ETHERLINK_ERROR_CONNECTION_FAILED: c_int = -2;
pub const ETHERLINK_ERROR_TRANSACTION_FAILED: c_int = -3;
pub const ETHERLINK_ERROR_INSUFFICIENT_FUNDS: c_int = -4;
pub const ETHERLINK_ERROR_INVALID_SIGNATURE: c_int = -5;
pub const ETHERLINK_ERROR_CONTRACT_ERROR: c_int = -6;
pub const ETHERLINK_ERROR_TIMEOUT: c_int = -7;
pub const ETHERLINK_ERROR_OUT_OF_MEMORY: c_int = -8;
pub const ETHERLINK_ERROR_SERIALIZATION_FAILED: c_int = -9;
pub const ETHERLINK_ERROR_NETWORK_MISMATCH: c_int = -10;

// Bridge operations
pub const ETHERLINK_OP_DEPOSIT: c_int = 1;
pub const ETHERLINK_OP_WITHDRAWAL: c_int = 2;
pub const ETHERLINK_OP_CLAIM: c_int = 3;

// Bridge status
pub const ETHERLINK_STATUS_PENDING: c_int = 0;
pub const ETHERLINK_STATUS_CONFIRMED: c_int = 1;
pub const ETHERLINK_STATUS_EXECUTED: c_int = 2;
pub const ETHERLINK_STATUS_FAILED: c_int = 3;
pub const ETHERLINK_STATUS_CANCELLED: c_int = 4;

// Event types
pub const ETHERLINK_EVENT_DEPOSIT: c_int = 1;
pub const ETHERLINK_EVENT_WITHDRAWAL: c_int = 2;
pub const ETHERLINK_EVENT_CLAIM: c_int = 3;
pub const ETHERLINK_EVENT_REFUND: c_int = 4;

// Network IDs
pub const ETHERLINK_NETWORK_ETHEREUM_MAINNET: c_int = 1;
pub const ETHERLINK_NETWORK_ETHEREUM_GOERLI: c_int = 5;
pub const ETHERLINK_NETWORK_GHOSTCHAIN_MAINNET: c_int = 9999;
pub const ETHERLINK_NETWORK_GHOSTCHAIN_TESTNET: c_int = 9998;

// Opaque handle types
#[repr(C)]
pub struct etherlink_bridge_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct etherlink_runtime_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct etherlink_deposit_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct etherlink_withdrawal_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct etherlink_event_monitor_t {
    _private: [u8; 0],
}

// Configuration structure
#[repr(C)]
#[derive(Debug, Clone)]
pub struct etherlink_config_t {
    pub ethereum_rpc_url: *const c_char,
    pub ethereum_ws_url: *const c_char,
    pub ghostchain_rpc_url: *const c_char,
    pub bridge_contract_address: [u8; 20],
    pub validator_private_key: [u8; 32],
    pub confirmation_blocks: u32,
    pub gas_limit: u64,
    pub gas_price_gwei: u64,
    pub enable_monitoring: c_int, // bool
}

// Bridge statistics
#[repr(C)]
#[derive(Debug, Clone)]
pub struct etherlink_stats_t {
    pub total_deposits: u64,
    pub total_withdrawals: u64,
    pub total_volume_eth: [u8; 32], // U256 in big-endian
    pub total_volume_ghost: [u8; 32], // U256 in big-endian
    pub active_deposits: u32,
    pub active_withdrawals: u32,
    pub last_processed_block: u64,
}

// Deposit request
#[repr(C)]
#[derive(Debug, Clone)]
pub struct etherlink_deposit_request_t {
    pub from_address: [u8; 20],
    pub to_address: [c_char; 64], // GhostChain address
    pub amount: [u8; 32], // U256 in big-endian
    pub token_address: [u8; 20], // 0x0 for ETH
    pub data: *const u8,
    pub data_len: size_t,
    pub gas_limit: u64,
}

// Withdrawal request
#[repr(C)]
#[derive(Debug, Clone)]
pub struct etherlink_withdrawal_request_t {
    pub from_address: [c_char; 64], // GhostChain address
    pub to_address: [u8; 20],
    pub amount: [u8; 32], // U256 in big-endian
    pub token_address: [u8; 20], // 0x0 for ETH
    pub nonce: u64,
    pub signature: [u8; 65], // ECDSA signature
}

// Bridge operation status
#[repr(C)]
#[derive(Debug, Clone)]
pub struct etherlink_operation_status_t {
    pub operation_id: [c_char; 128],
    pub operation_type: c_int,
    pub status: c_int,
    pub eth_tx_hash: [c_char; 128],
    pub ghost_tx_hash: [c_char; 128],
    pub confirmations: u32,
    pub required_confirmations: u32,
    pub created_at: u64,
    pub updated_at: u64,
    pub error_message: [c_char; 256],
}

// Bridge event
#[repr(C)]
#[derive(Debug, Clone)]
pub struct etherlink_event_t {
    pub event_type: c_int,
    pub block_number: u64,
    pub transaction_hash: [c_char; 128],
    pub log_index: u32,
    pub from_address: [u8; 20],
    pub to_address: [u8; 20],
    pub amount: [u8; 32], // U256 in big-endian
    pub data_size: size_t,
}

// Token information
#[repr(C)]
#[derive(Debug, Clone)]
pub struct etherlink_token_info_t {
    pub address: [u8; 20],
    pub symbol: [c_char; 16],
    pub name: [c_char; 64],
    pub decimals: u8,
    pub is_mintable: c_int, // bool
    pub total_bridged: [u8; 32], // U256 in big-endian
}

// Internal structures
struct InternalBridge {
    bridge: EtherLink,
    runtime: Runtime,
}

struct InternalDeposit {
    deposit: DepositRequest,
}

struct InternalWithdrawal {
    withdrawal: WithdrawalRequest,
}

struct InternalEventMonitor {
    // Event monitoring implementation
}

// Version information
#[no_mangle]
pub extern "C" fn etherlink_version_string() -> *const c_char {
    b"etherlink 0.1.0\0".as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn etherlink_version_major() -> c_uint {
    0
}

#[no_mangle]
pub extern "C" fn etherlink_version_minor() -> c_uint {
    1
}

#[no_mangle]
pub extern "C" fn etherlink_version_patch() -> c_uint {
    0
}

// Runtime management
#[no_mangle]
pub extern "C" fn etherlink_runtime_new() -> *mut etherlink_runtime_t {
    let runtime = match Runtime::new() {
        Ok(rt) => rt,
        Err(_) => return ptr::null_mut(),
    };

    let boxed = Box::new(runtime);
    Box::into_raw(boxed) as *mut etherlink_runtime_t
}

#[no_mangle]
pub extern "C" fn etherlink_runtime_free(runtime: *mut etherlink_runtime_t) {
    if !runtime.is_null() {
        unsafe {
            let _ = Box::from_raw(runtime as *mut Runtime);
        }
    }
}

// Bridge management
#[no_mangle]
pub extern "C" fn etherlink_bridge_new(
    runtime: *mut etherlink_runtime_t,
    config: *const etherlink_config_t,
) -> *mut etherlink_bridge_t {
    if runtime.is_null() || config.is_null() {
        return ptr::null_mut();
    }

    let rt = unsafe { &*(runtime as *mut Runtime) };
    let cfg = unsafe { &*config };

    // Convert C config to Rust config
    let ethereum_rpc = if cfg.ethereum_rpc_url.is_null() {
        return ptr::null_mut();
    } else {
        unsafe {
            match CStr::from_ptr(cfg.ethereum_rpc_url).to_str() {
                Ok(s) => s.to_string(),
                Err(_) => return ptr::null_mut(),
            }
        }
    };

    let ethereum_ws = if cfg.ethereum_ws_url.is_null() {
        None
    } else {
        unsafe { CStr::from_ptr(cfg.ethereum_ws_url).to_str().ok().map(|s| s.to_string()) }
    };

    let ghostchain_rpc = if cfg.ghostchain_rpc_url.is_null() {
        return ptr::null_mut();
    } else {
        unsafe {
            match CStr::from_ptr(cfg.ghostchain_rpc_url).to_str() {
                Ok(s) => s.to_string(),
                Err(_) => return ptr::null_mut(),
            }
        }
    };

    let bridge_config = BridgeConfig {
        ethereum_rpc_url: ethereum_rpc,
        ethereum_ws_url: ethereum_ws,
        ghostchain_rpc_url: ghostchain_rpc,
        bridge_contract_address: Address::from(cfg.bridge_contract_address),
        validator_private_key: cfg.validator_private_key,
        confirmation_blocks: cfg.confirmation_blocks,
        gas_limit: cfg.gas_limit,
        gas_price_gwei: cfg.gas_price_gwei,
        enable_monitoring: cfg.enable_monitoring != 0,
    };

    let bridge = match rt.block_on(async {
        EtherLink::new(bridge_config).await
    }) {
        Ok(b) => b,
        Err(_) => return ptr::null_mut(),
    };

    let internal_bridge = InternalBridge {
        bridge,
        runtime: Runtime::new().unwrap(),
    };

    let boxed = Box::new(internal_bridge);
    Box::into_raw(boxed) as *mut etherlink_bridge_t
}

#[no_mangle]
pub extern "C" fn etherlink_bridge_free(bridge: *mut etherlink_bridge_t) {
    if !bridge.is_null() {
        unsafe {
            let _ = Box::from_raw(bridge as *mut InternalBridge);
        }
    }
}

// Bridge operations
#[no_mangle]
pub extern "C" fn etherlink_get_bridge_stats(
    bridge: *mut etherlink_bridge_t,
    stats: *mut etherlink_stats_t,
) -> c_int {
    if bridge.is_null() || stats.is_null() {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };

    let bridge_stats = match internal_bridge.runtime.block_on(async {
        internal_bridge.bridge.get_stats().await
    }) {
        Ok(s) => s,
        Err(_) => return ETHERLINK_ERROR_CONNECTION_FAILED,
    };

    unsafe {
        (*stats).total_deposits = bridge_stats.total_deposits;
        (*stats).total_withdrawals = bridge_stats.total_withdrawals;
        (*stats).total_volume_eth = bridge_stats.total_volume_eth.to_big_endian_bytes();
        (*stats).total_volume_ghost = bridge_stats.total_volume_ghost.to_big_endian_bytes();
        (*stats).active_deposits = bridge_stats.active_deposits;
        (*stats).active_withdrawals = bridge_stats.active_withdrawals;
        (*stats).last_processed_block = bridge_stats.last_processed_block;
    }

    ETHERLINK_SUCCESS
}

#[no_mangle]
pub extern "C" fn etherlink_get_supported_tokens(
    bridge: *mut etherlink_bridge_t,
    tokens: *mut etherlink_token_info_t,
    max_tokens: size_t,
    actual_count: *mut size_t,
) -> c_int {
    if bridge.is_null() || tokens.is_null() || actual_count.is_null() {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };

    let supported_tokens = match internal_bridge.runtime.block_on(async {
        internal_bridge.bridge.get_supported_tokens().await
    }) {
        Ok(t) => t,
        Err(_) => return ETHERLINK_ERROR_CONNECTION_FAILED,
    };

    let count = supported_tokens.len().min(max_tokens);
    unsafe {
        for (i, token) in supported_tokens.iter().take(count).enumerate() {
            let token_info = tokens.add(i);
            (*token_info).address = token.address.0;

            // Copy symbol
            let symbol_bytes = token.symbol.as_bytes();
            let symbol_len = symbol_bytes.len().min(15);
            (*token_info).symbol[..symbol_len].copy_from_slice(
                &symbol_bytes[..symbol_len].iter().map(|&b| b as c_char).collect::<Vec<_>>()
            );
            (*token_info).symbol[symbol_len] = 0;

            // Copy name
            let name_bytes = token.name.as_bytes();
            let name_len = name_bytes.len().min(63);
            (*token_info).name[..name_len].copy_from_slice(
                &name_bytes[..name_len].iter().map(|&b| b as c_char).collect::<Vec<_>>()
            );
            (*token_info).name[name_len] = 0;

            (*token_info).decimals = token.decimals;
            (*token_info).is_mintable = if token.is_mintable { 1 } else { 0 };
            (*token_info).total_bridged = token.total_bridged.to_big_endian_bytes();
        }
        *actual_count = supported_tokens.len();
    }

    ETHERLINK_SUCCESS
}

// Deposit operations
#[no_mangle]
pub extern "C" fn etherlink_create_deposit(
    bridge: *mut etherlink_bridge_t,
    request: *const etherlink_deposit_request_t,
) -> *mut etherlink_deposit_t {
    if bridge.is_null() || request.is_null() {
        return ptr::null_mut();
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };
    let req = unsafe { &*request };

    // Convert to GhostChain address
    let to_address = unsafe {
        match CStr::from_ptr(req.to_address.as_ptr()).to_str() {
            Ok(s) => s.to_string(),
            Err(_) => return ptr::null_mut(),
        }
    };

    let data = if req.data.is_null() {
        vec![]
    } else {
        unsafe { slice::from_raw_parts(req.data, req.data_len).to_vec() }
    };

    let deposit_request = DepositRequest {
        from_address: Address::from(req.from_address),
        to_address,
        amount: U256::from_big_endian(&req.amount),
        token_address: Address::from(req.token_address),
        data,
        gas_limit: req.gas_limit,
    };

    let deposit = match internal_bridge.runtime.block_on(async {
        internal_bridge.bridge.create_deposit(deposit_request).await
    }) {
        Ok(d) => d,
        Err(_) => return ptr::null_mut(),
    };

    let internal_deposit = InternalDeposit { deposit };
    let boxed = Box::new(internal_deposit);
    Box::into_raw(boxed) as *mut etherlink_deposit_t
}

#[no_mangle]
pub extern "C" fn etherlink_submit_deposit(
    bridge: *mut etherlink_bridge_t,
    deposit: *mut etherlink_deposit_t,
) -> c_int {
    if bridge.is_null() || deposit.is_null() {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };
    let internal_deposit = unsafe { &*(deposit as *mut InternalDeposit) };

    let result = internal_bridge.runtime.block_on(async {
        internal_bridge.bridge.submit_deposit(&internal_deposit.deposit).await
    });

    match result {
        Ok(_) => ETHERLINK_SUCCESS,
        Err(_) => ETHERLINK_ERROR_TRANSACTION_FAILED,
    }
}

#[no_mangle]
pub extern "C" fn etherlink_deposit_free(deposit: *mut etherlink_deposit_t) {
    if !deposit.is_null() {
        unsafe {
            let _ = Box::from_raw(deposit as *mut InternalDeposit);
        }
    }
}

// Withdrawal operations
#[no_mangle]
pub extern "C" fn etherlink_create_withdrawal(
    bridge: *mut etherlink_bridge_t,
    request: *const etherlink_withdrawal_request_t,
) -> *mut etherlink_withdrawal_t {
    if bridge.is_null() || request.is_null() {
        return ptr::null_mut();
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };
    let req = unsafe { &*request };

    // Convert from GhostChain address
    let from_address = unsafe {
        match CStr::from_ptr(req.from_address.as_ptr()).to_str() {
            Ok(s) => s.to_string(),
            Err(_) => return ptr::null_mut(),
        }
    };

    let withdrawal_request = WithdrawalRequest {
        from_address,
        to_address: Address::from(req.to_address),
        amount: U256::from_big_endian(&req.amount),
        token_address: Address::from(req.token_address),
        nonce: req.nonce,
        signature: req.signature,
    };

    let withdrawal = match internal_bridge.runtime.block_on(async {
        internal_bridge.bridge.create_withdrawal(withdrawal_request).await
    }) {
        Ok(w) => w,
        Err(_) => return ptr::null_mut(),
    };

    let internal_withdrawal = InternalWithdrawal { withdrawal };
    let boxed = Box::new(internal_withdrawal);
    Box::into_raw(boxed) as *mut etherlink_withdrawal_t
}

#[no_mangle]
pub extern "C" fn etherlink_submit_withdrawal(
    bridge: *mut etherlink_bridge_t,
    withdrawal: *mut etherlink_withdrawal_t,
) -> c_int {
    if bridge.is_null() || withdrawal.is_null() {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };
    let internal_withdrawal = unsafe { &*(withdrawal as *mut InternalWithdrawal) };

    let result = internal_bridge.runtime.block_on(async {
        internal_bridge.bridge.submit_withdrawal(&internal_withdrawal.withdrawal).await
    });

    match result {
        Ok(_) => ETHERLINK_SUCCESS,
        Err(_) => ETHERLINK_ERROR_TRANSACTION_FAILED,
    }
}

#[no_mangle]
pub extern "C" fn etherlink_withdrawal_free(withdrawal: *mut etherlink_withdrawal_t) {
    if !withdrawal.is_null() {
        unsafe {
            let _ = Box::from_raw(withdrawal as *mut InternalWithdrawal);
        }
    }
}

// Status and monitoring
#[no_mangle]
pub extern "C" fn etherlink_get_operation_status(
    bridge: *mut etherlink_bridge_t,
    operation_id: *const c_char,
    status: *mut etherlink_operation_status_t,
) -> c_int {
    if bridge.is_null() || operation_id.is_null() || status.is_null() {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };

    let id_str = unsafe {
        match CStr::from_ptr(operation_id).to_str() {
            Ok(s) => s,
            Err(_) => return ETHERLINK_ERROR_INVALID_INPUT,
        }
    };

    let operation_status = match internal_bridge.runtime.block_on(async {
        internal_bridge.bridge.get_operation_status(id_str).await
    }) {
        Ok(s) => s,
        Err(_) => return ETHERLINK_ERROR_CONNECTION_FAILED,
    };

    unsafe {
        // Copy operation ID
        let id_bytes = operation_status.operation_id.as_bytes();
        let id_len = id_bytes.len().min(127);
        (*status).operation_id[..id_len].copy_from_slice(
            &id_bytes[..id_len].iter().map(|&b| b as c_char).collect::<Vec<_>>()
        );
        (*status).operation_id[id_len] = 0;

        (*status).operation_type = match operation_status.operation_type {
            etherlink::OperationType::Deposit => ETHERLINK_OP_DEPOSIT,
            etherlink::OperationType::Withdrawal => ETHERLINK_OP_WITHDRAWAL,
            etherlink::OperationType::Claim => ETHERLINK_OP_CLAIM,
        };

        (*status).status = match operation_status.status {
            etherlink::OperationStatus::Pending => ETHERLINK_STATUS_PENDING,
            etherlink::OperationStatus::Confirmed => ETHERLINK_STATUS_CONFIRMED,
            etherlink::OperationStatus::Executed => ETHERLINK_STATUS_EXECUTED,
            etherlink::OperationStatus::Failed => ETHERLINK_STATUS_FAILED,
            etherlink::OperationStatus::Cancelled => ETHERLINK_STATUS_CANCELLED,
        };

        // Copy transaction hashes
        if let Some(eth_hash) = operation_status.eth_tx_hash {
            let hash_str = format!("{:?}", eth_hash);
            let hash_bytes = hash_str.as_bytes();
            let hash_len = hash_bytes.len().min(127);
            (*status).eth_tx_hash[..hash_len].copy_from_slice(
                &hash_bytes[..hash_len].iter().map(|&b| b as c_char).collect::<Vec<_>>()
            );
            (*status).eth_tx_hash[hash_len] = 0;
        }

        if let Some(ghost_hash) = operation_status.ghost_tx_hash {
            let hash_bytes = ghost_hash.as_bytes();
            let hash_len = hash_bytes.len().min(127);
            (*status).ghost_tx_hash[..hash_len].copy_from_slice(
                &hash_bytes[..hash_len].iter().map(|&b| b as c_char).collect::<Vec<_>>()
            );
            (*status).ghost_tx_hash[hash_len] = 0;
        }

        (*status).confirmations = operation_status.confirmations;
        (*status).required_confirmations = operation_status.required_confirmations;
        (*status).created_at = operation_status.created_at;
        (*status).updated_at = operation_status.updated_at;

        // Copy error message if any
        if let Some(error) = operation_status.error_message {
            let error_bytes = error.as_bytes();
            let error_len = error_bytes.len().min(255);
            (*status).error_message[..error_len].copy_from_slice(
                &error_bytes[..error_len].iter().map(|&b| b as c_char).collect::<Vec<_>>()
            );
            (*status).error_message[error_len] = 0;
        }
    }

    ETHERLINK_SUCCESS
}

// Event monitoring
#[no_mangle]
pub extern "C" fn etherlink_start_event_monitoring(
    bridge: *mut etherlink_bridge_t,
) -> *mut etherlink_event_monitor_t {
    if bridge.is_null() {
        return ptr::null_mut();
    }

    let internal_bridge = unsafe { &*(bridge as *mut InternalBridge) };

    let monitor = match internal_bridge.runtime.block_on(async {
        internal_bridge.bridge.start_event_monitoring().await
    }) {
        Ok(m) => m,
        Err(_) => return ptr::null_mut(),
    };

    let internal_monitor = InternalEventMonitor { /* monitor */ };
    let boxed = Box::new(internal_monitor);
    Box::into_raw(boxed) as *mut etherlink_event_monitor_t
}

#[no_mangle]
pub extern "C" fn etherlink_get_recent_events(
    monitor: *mut etherlink_event_monitor_t,
    events: *mut etherlink_event_t,
    max_events: size_t,
    actual_count: *mut size_t,
) -> c_int {
    if monitor.is_null() || events.is_null() || actual_count.is_null() {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    // Simplified implementation - in practice would get actual events
    let recent_events = vec![]; // Would contain actual bridge events

    let count = recent_events.len().min(max_events);
    unsafe {
        *actual_count = recent_events.len();
    }

    // Copy events to buffer
    for (i, event) in recent_events.iter().take(count).enumerate() {
        unsafe {
            let event_entry = events.add(i);
            // Copy event data
            // Implementation would copy actual event data
        }
    }

    ETHERLINK_SUCCESS
}

#[no_mangle]
pub extern "C" fn etherlink_event_monitor_free(monitor: *mut etherlink_event_monitor_t) {
    if !monitor.is_null() {
        unsafe {
            let _ = Box::from_raw(monitor as *mut InternalEventMonitor);
        }
    }
}

// Utility functions
#[no_mangle]
pub extern "C" fn etherlink_error_string(error_code: c_int) -> *const c_char {
    match error_code {
        ETHERLINK_SUCCESS => b"Success\0",
        ETHERLINK_ERROR_INVALID_INPUT => b"Invalid input\0",
        ETHERLINK_ERROR_CONNECTION_FAILED => b"Connection failed\0",
        ETHERLINK_ERROR_TRANSACTION_FAILED => b"Transaction failed\0",
        ETHERLINK_ERROR_INSUFFICIENT_FUNDS => b"Insufficient funds\0",
        ETHERLINK_ERROR_INVALID_SIGNATURE => b"Invalid signature\0",
        ETHERLINK_ERROR_CONTRACT_ERROR => b"Smart contract error\0",
        ETHERLINK_ERROR_TIMEOUT => b"Operation timed out\0",
        ETHERLINK_ERROR_OUT_OF_MEMORY => b"Out of memory\0",
        ETHERLINK_ERROR_SERIALIZATION_FAILED => b"Serialization failed\0",
        ETHERLINK_ERROR_NETWORK_MISMATCH => b"Network mismatch\0",
        _ => b"Unknown error\0",
    }.as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn etherlink_operation_type_name(operation_type: c_int) -> *const c_char {
    match operation_type {
        ETHERLINK_OP_DEPOSIT => b"Deposit\0",
        ETHERLINK_OP_WITHDRAWAL => b"Withdrawal\0",
        ETHERLINK_OP_CLAIM => b"Claim\0",
        _ => b"Unknown\0",
    }.as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn etherlink_status_name(status: c_int) -> *const c_char {
    match status {
        ETHERLINK_STATUS_PENDING => b"Pending\0",
        ETHERLINK_STATUS_CONFIRMED => b"Confirmed\0",
        ETHERLINK_STATUS_EXECUTED => b"Executed\0",
        ETHERLINK_STATUS_FAILED => b"Failed\0",
        ETHERLINK_STATUS_CANCELLED => b"Cancelled\0",
        _ => b"Unknown\0",
    }.as_ptr() as *const c_char
}

// Address conversion utilities
#[no_mangle]
pub extern "C" fn etherlink_address_from_hex(
    hex_string: *const c_char,
    address: *mut u8,
) -> c_int {
    if hex_string.is_null() || address.is_null() {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    let hex_str = unsafe {
        match CStr::from_ptr(hex_string).to_str() {
            Ok(s) => s,
            Err(_) => return ETHERLINK_ERROR_INVALID_INPUT,
        }
    };

    // Remove 0x prefix if present
    let hex_str = if hex_str.starts_with("0x") {
        &hex_str[2..]
    } else {
        hex_str
    };

    if hex_str.len() != 40 {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    match hex::decode(hex_str) {
        Ok(bytes) => {
            if bytes.len() == 20 {
                unsafe {
                    let addr_slice = slice::from_raw_parts_mut(address, 20);
                    addr_slice.copy_from_slice(&bytes);
                }
                ETHERLINK_SUCCESS
            } else {
                ETHERLINK_ERROR_INVALID_INPUT
            }
        }
        Err(_) => ETHERLINK_ERROR_INVALID_INPUT,
    }
}

#[no_mangle]
pub extern "C" fn etherlink_address_to_hex(
    address: *const u8,
    hex_string: *mut c_char,
    buffer_size: size_t,
) -> c_int {
    if address.is_null() || hex_string.is_null() || buffer_size < 43 {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    let addr_slice = unsafe { slice::from_raw_parts(address, 20) };
    let hex_str = format!("0x{}", hex::encode(addr_slice));

    if hex_str.len() + 1 > buffer_size {
        return ETHERLINK_ERROR_INVALID_INPUT;
    }

    unsafe {
        let hex_bytes = hex_str.as_bytes();
        let buffer_slice = slice::from_raw_parts_mut(hex_string as *mut u8, buffer_size);
        buffer_slice[..hex_bytes.len()].copy_from_slice(hex_bytes);
        buffer_slice[hex_bytes.len()] = 0;
    }

    ETHERLINK_SUCCESS
}
```

### Generated C Header

```c
/* Auto-generated by cbindgen */

#ifndef ETHERLINK_H
#define ETHERLINK_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Error codes
 */
#define ETHERLINK_SUCCESS 0
#define ETHERLINK_ERROR_INVALID_INPUT -1
#define ETHERLINK_ERROR_CONNECTION_FAILED -2
#define ETHERLINK_ERROR_TRANSACTION_FAILED -3
#define ETHERLINK_ERROR_INSUFFICIENT_FUNDS -4
#define ETHERLINK_ERROR_INVALID_SIGNATURE -5
#define ETHERLINK_ERROR_CONTRACT_ERROR -6
#define ETHERLINK_ERROR_TIMEOUT -7
#define ETHERLINK_ERROR_OUT_OF_MEMORY -8
#define ETHERLINK_ERROR_SERIALIZATION_FAILED -9
#define ETHERLINK_ERROR_NETWORK_MISMATCH -10

/**
 * Bridge operations
 */
#define ETHERLINK_OP_DEPOSIT 1
#define ETHERLINK_OP_WITHDRAWAL 2
#define ETHERLINK_OP_CLAIM 3

/**
 * Bridge status
 */
#define ETHERLINK_STATUS_PENDING 0
#define ETHERLINK_STATUS_CONFIRMED 1
#define ETHERLINK_STATUS_EXECUTED 2
#define ETHERLINK_STATUS_FAILED 3
#define ETHERLINK_STATUS_CANCELLED 4

/**
 * Event types
 */
#define ETHERLINK_EVENT_DEPOSIT 1
#define ETHERLINK_EVENT_WITHDRAWAL 2
#define ETHERLINK_EVENT_CLAIM 3
#define ETHERLINK_EVENT_REFUND 4

/**
 * Network IDs
 */
#define ETHERLINK_NETWORK_ETHEREUM_MAINNET 1
#define ETHERLINK_NETWORK_ETHEREUM_GOERLI 5
#define ETHERLINK_NETWORK_GHOSTCHAIN_MAINNET 9999
#define ETHERLINK_NETWORK_GHOSTCHAIN_TESTNET 9998

/**
 * Opaque bridge handle
 */
typedef struct etherlink_bridge_t etherlink_bridge_t;

/**
 * Opaque runtime handle
 */
typedef struct etherlink_runtime_t etherlink_runtime_t;

/**
 * Opaque deposit handle
 */
typedef struct etherlink_deposit_t etherlink_deposit_t;

/**
 * Opaque withdrawal handle
 */
typedef struct etherlink_withdrawal_t etherlink_withdrawal_t;

/**
 * Opaque event monitor handle
 */
typedef struct etherlink_event_monitor_t etherlink_event_monitor_t;

/**
 * Bridge configuration
 */
typedef struct etherlink_config_t {
  const char *ethereum_rpc_url;
  const char *ethereum_ws_url;
  const char *ghostchain_rpc_url;
  uint8_t bridge_contract_address[20];
  uint8_t validator_private_key[32];
  uint32_t confirmation_blocks;
  uint64_t gas_limit;
  uint64_t gas_price_gwei;
  int enable_monitoring;
} etherlink_config_t;

/**
 * Bridge statistics
 */
typedef struct etherlink_stats_t {
  uint64_t total_deposits;
  uint64_t total_withdrawals;
  uint8_t total_volume_eth[32];
  uint8_t total_volume_ghost[32];
  uint32_t active_deposits;
  uint32_t active_withdrawals;
  uint64_t last_processed_block;
} etherlink_stats_t;

/**
 * Deposit request
 */
typedef struct etherlink_deposit_request_t {
  uint8_t from_address[20];
  char to_address[64];
  uint8_t amount[32];
  uint8_t token_address[20];
  const uint8_t *data;
  size_t data_len;
  uint64_t gas_limit;
} etherlink_deposit_request_t;

/**
 * Withdrawal request
 */
typedef struct etherlink_withdrawal_request_t {
  char from_address[64];
  uint8_t to_address[20];
  uint8_t amount[32];
  uint8_t token_address[20];
  uint64_t nonce;
  uint8_t signature[65];
} etherlink_withdrawal_request_t;

/**
 * Bridge operation status
 */
typedef struct etherlink_operation_status_t {
  char operation_id[128];
  int operation_type;
  int status;
  char eth_tx_hash[128];
  char ghost_tx_hash[128];
  uint32_t confirmations;
  uint32_t required_confirmations;
  uint64_t created_at;
  uint64_t updated_at;
  char error_message[256];
} etherlink_operation_status_t;

/**
 * Bridge event
 */
typedef struct etherlink_event_t {
  int event_type;
  uint64_t block_number;
  char transaction_hash[128];
  uint32_t log_index;
  uint8_t from_address[20];
  uint8_t to_address[20];
  uint8_t amount[32];
  size_t data_size;
} etherlink_event_t;

/**
 * Token information
 */
typedef struct etherlink_token_info_t {
  uint8_t address[20];
  char symbol[16];
  char name[64];
  uint8_t decimals;
  int is_mintable;
  uint8_t total_bridged[32];
} etherlink_token_info_t;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get EtherLink version string
 */
const char *etherlink_version_string(void);

/**
 * Get major version number
 */
unsigned int etherlink_version_major(void);

/**
 * Get minor version number
 */
unsigned int etherlink_version_minor(void);

/**
 * Get patch version number
 */
unsigned int etherlink_version_patch(void);

/**
 * Create a new async runtime
 */
etherlink_runtime_t *etherlink_runtime_new(void);

/**
 * Free async runtime
 */
void etherlink_runtime_free(etherlink_runtime_t *runtime);

/**
 * Create a new bridge instance
 */
etherlink_bridge_t *etherlink_bridge_new(etherlink_runtime_t *runtime,
                                        const etherlink_config_t *config);

/**
 * Free bridge instance
 */
void etherlink_bridge_free(etherlink_bridge_t *bridge);

/**
 * Get bridge statistics
 */
int etherlink_get_bridge_stats(etherlink_bridge_t *bridge,
                              etherlink_stats_t *stats);

/**
 * Get supported tokens
 */
int etherlink_get_supported_tokens(etherlink_bridge_t *bridge,
                                  etherlink_token_info_t *tokens,
                                  size_t max_tokens,
                                  size_t *actual_count);

/**
 * Create a deposit request
 */
etherlink_deposit_t *etherlink_create_deposit(etherlink_bridge_t *bridge,
                                             const etherlink_deposit_request_t *request);

/**
 * Submit deposit to Ethereum
 */
int etherlink_submit_deposit(etherlink_bridge_t *bridge,
                           etherlink_deposit_t *deposit);

/**
 * Free deposit
 */
void etherlink_deposit_free(etherlink_deposit_t *deposit);

/**
 * Create a withdrawal request
 */
etherlink_withdrawal_t *etherlink_create_withdrawal(etherlink_bridge_t *bridge,
                                                   const etherlink_withdrawal_request_t *request);

/**
 * Submit withdrawal to Ethereum
 */
int etherlink_submit_withdrawal(etherlink_bridge_t *bridge,
                              etherlink_withdrawal_t *withdrawal);

/**
 * Free withdrawal
 */
void etherlink_withdrawal_free(etherlink_withdrawal_t *withdrawal);

/**
 * Get operation status
 */
int etherlink_get_operation_status(etherlink_bridge_t *bridge,
                                  const char *operation_id,
                                  etherlink_operation_status_t *status);

/**
 * Start event monitoring
 */
etherlink_event_monitor_t *etherlink_start_event_monitoring(etherlink_bridge_t *bridge);

/**
 * Get recent bridge events
 */
int etherlink_get_recent_events(etherlink_event_monitor_t *monitor,
                               etherlink_event_t *events,
                               size_t max_events,
                               size_t *actual_count);

/**
 * Free event monitor
 */
void etherlink_event_monitor_free(etherlink_event_monitor_t *monitor);

/**
 * Get error message for error code
 */
const char *etherlink_error_string(int error_code);

/**
 * Get operation type name
 */
const char *etherlink_operation_type_name(int operation_type);

/**
 * Get status name
 */
const char *etherlink_status_name(int status);

/**
 * Convert hex string to address
 */
int etherlink_address_from_hex(const char *hex_string, uint8_t *address);

/**
 * Convert address to hex string
 */
int etherlink_address_to_hex(const uint8_t *address,
                            char *hex_string,
                            size_t buffer_size);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* ETHERLINK_H */
```

## C Usage

### Basic C Example

```c
// bridge_example.c
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "etherlink.h"

void test_bridge_initialization();
void test_deposit_operation();
void test_withdrawal_operation();
void test_event_monitoring();

int main() {
    printf("EtherLink version: %s\n", etherlink_version_string());

    test_bridge_initialization();
    test_deposit_operation();
    test_withdrawal_operation();
    test_event_monitoring();

    printf("All EtherLink tests completed!\n");
    return 0;
}

void test_bridge_initialization() {
    printf("\n=== Bridge Initialization Test ===\n");

    // Create runtime
    etherlink_runtime_t *runtime = etherlink_runtime_new();
    assert(runtime != NULL);

    // Configure bridge
    etherlink_config_t config = {
        .ethereum_rpc_url = "https://mainnet.infura.io/v3/YOUR_KEY",
        .ethereum_ws_url = "wss://mainnet.infura.io/ws/v3/YOUR_KEY",
        .ghostchain_rpc_url = "https://rpc.ghostchain.io",
        .confirmation_blocks = 12,
        .gas_limit = 300000,
        .gas_price_gwei = 20,
        .enable_monitoring = 1,
    };

    // Set bridge contract address
    etherlink_address_from_hex(
        "0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B",
        config.bridge_contract_address
    );

    // Set validator private key (example - don't use in production)
    memset(config.validator_private_key, 0x42, 32);

    // Create bridge
    etherlink_bridge_t *bridge = etherlink_bridge_new(runtime, &config);
    assert(bridge != NULL);

    printf("✓ Bridge initialized successfully\n");

    // Get bridge stats
    etherlink_stats_t stats;
    int result = etherlink_get_bridge_stats(bridge, &stats);
    if (result == ETHERLINK_SUCCESS) {
        printf("✓ Bridge statistics:\n");
        printf("  - Total deposits: %lu\n", stats.total_deposits);
        printf("  - Total withdrawals: %lu\n", stats.total_withdrawals);
        printf("  - Active deposits: %u\n", stats.active_deposits);
        printf("  - Last processed block: %lu\n", stats.last_processed_block);
    }

    // Get supported tokens
    etherlink_token_info_t tokens[10];
    size_t actual_count;
    result = etherlink_get_supported_tokens(bridge, tokens, 10, &actual_count);
    if (result == ETHERLINK_SUCCESS) {
        printf("✓ Supported tokens (%zu):\n", actual_count);
        for (size_t i = 0; i < actual_count; i++) {
            char addr_hex[43];
            etherlink_address_to_hex(tokens[i].address, addr_hex, sizeof(addr_hex));
            printf("  - %s (%s): %s\n", tokens[i].symbol, tokens[i].name, addr_hex);
        }
    }

    // Cleanup
    etherlink_bridge_free(bridge);
    etherlink_runtime_free(runtime);
    printf("✓ Bridge cleanup completed\n");
}

void test_deposit_operation() {
    printf("\n=== Deposit Operation Test ===\n");

    // Setup bridge (simplified)
    etherlink_runtime_t *runtime = etherlink_runtime_new();
    etherlink_config_t config = {
        .ethereum_rpc_url = "https://goerli.infura.io/v3/YOUR_KEY",
        .ghostchain_rpc_url = "https://testnet-rpc.ghostchain.io",
        .confirmation_blocks = 3,
        .gas_limit = 300000,
        .gas_price_gwei = 20,
        .enable_monitoring = 1,
    };

    etherlink_address_from_hex(
        "0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B",
        config.bridge_contract_address
    );

    etherlink_bridge_t *bridge = etherlink_bridge_new(runtime, &config);
    assert(bridge != NULL);

    // Create deposit request
    etherlink_deposit_request_t deposit_request = {
        .gas_limit = 100000,
        .data = NULL,
        .data_len = 0,
    };

    // Set from address (Ethereum)
    etherlink_address_from_hex(
        "0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B",
        deposit_request.from_address
    );

    // Set to address (GhostChain)
    strcpy(deposit_request.to_address, "ghost1abcd1234567890abcd1234567890abcd123456");

    // Set amount (1 ETH = 1e18 wei)
    memset(deposit_request.amount, 0, 32);
    deposit_request.amount[31] = 1; // Very small amount for test

    // Set token address (0x0 for ETH)
    memset(deposit_request.token_address, 0, 20);

    // Create deposit
    etherlink_deposit_t *deposit = etherlink_create_deposit(bridge, &deposit_request);
    if (deposit != NULL) {
        printf("✓ Deposit created successfully\n");

        // Submit deposit
        int result = etherlink_submit_deposit(bridge, deposit);
        if (result == ETHERLINK_SUCCESS) {
            printf("✓ Deposit submitted to Ethereum\n");
        } else {
            printf("✗ Deposit submission failed: %s\n",
                   etherlink_error_string(result));
        }

        etherlink_deposit_free(deposit);
    } else {
        printf("✗ Failed to create deposit\n");
    }

    etherlink_bridge_free(bridge);
    etherlink_runtime_free(runtime);
}

void test_withdrawal_operation() {
    printf("\n=== Withdrawal Operation Test ===\n");

    // Setup bridge
    etherlink_runtime_t *runtime = etherlink_runtime_new();
    etherlink_config_t config = {
        .ethereum_rpc_url = "https://goerli.infura.io/v3/YOUR_KEY",
        .ghostchain_rpc_url = "https://testnet-rpc.ghostchain.io",
        .confirmation_blocks = 3,
        .gas_limit = 300000,
        .gas_price_gwei = 20,
        .enable_monitoring = 1,
    };

    etherlink_bridge_t *bridge = etherlink_bridge_new(runtime, &config);
    assert(bridge != NULL);

    // Create withdrawal request
    etherlink_withdrawal_request_t withdrawal_request = {
        .nonce = 1,
    };

    // Set from address (GhostChain)
    strcpy(withdrawal_request.from_address, "ghost1abcd1234567890abcd1234567890abcd123456");

    // Set to address (Ethereum)
    etherlink_address_from_hex(
        "0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B",
        withdrawal_request.to_address
    );

    // Set amount
    memset(withdrawal_request.amount, 0, 32);
    withdrawal_request.amount[31] = 1; // Small amount

    // Set token address (0x0 for ETH)
    memset(withdrawal_request.token_address, 0, 20);

    // Set signature (example - would be real signature in practice)
    memset(withdrawal_request.signature, 0x12, 65);

    // Create withdrawal
    etherlink_withdrawal_t *withdrawal = etherlink_create_withdrawal(bridge, &withdrawal_request);
    if (withdrawal != NULL) {
        printf("✓ Withdrawal created successfully\n");

        // Submit withdrawal
        int result = etherlink_submit_withdrawal(bridge, withdrawal);
        if (result == ETHERLINK_SUCCESS) {
            printf("✓ Withdrawal submitted to Ethereum\n");
        } else {
            printf("✗ Withdrawal submission failed: %s\n",
                   etherlink_error_string(result));
        }

        etherlink_withdrawal_free(withdrawal);
    } else {
        printf("✗ Failed to create withdrawal\n");
    }

    etherlink_bridge_free(bridge);
    etherlink_runtime_free(runtime);
}

void test_event_monitoring() {
    printf("\n=== Event Monitoring Test ===\n");

    // Setup bridge
    etherlink_runtime_t *runtime = etherlink_runtime_new();
    etherlink_config_t config = {
        .ethereum_rpc_url = "https://mainnet.infura.io/v3/YOUR_KEY",
        .ethereum_ws_url = "wss://mainnet.infura.io/ws/v3/YOUR_KEY",
        .ghostchain_rpc_url = "https://rpc.ghostchain.io",
        .enable_monitoring = 1,
    };

    etherlink_bridge_t *bridge = etherlink_bridge_new(runtime, &config);
    assert(bridge != NULL);

    // Start event monitoring
    etherlink_event_monitor_t *monitor = etherlink_start_event_monitoring(bridge);
    if (monitor != NULL) {
        printf("✓ Event monitoring started\n");

        // Get recent events
        etherlink_event_t events[50];
        size_t actual_count;
        int result = etherlink_get_recent_events(monitor, events, 50, &actual_count);

        if (result == ETHERLINK_SUCCESS) {
            printf("✓ Retrieved %zu recent events\n", actual_count);

            for (size_t i = 0; i < actual_count; i++) {
                printf("  Event %zu:\n", i + 1);
                printf("    - Type: %s\n",
                       events[i].event_type == ETHERLINK_EVENT_DEPOSIT ? "Deposit" :
                       events[i].event_type == ETHERLINK_EVENT_WITHDRAWAL ? "Withdrawal" :
                       events[i].event_type == ETHERLINK_EVENT_CLAIM ? "Claim" : "Unknown");
                printf("    - Block: %lu\n", events[i].block_number);
                printf("    - TX Hash: %s\n", events[i].transaction_hash);
            }
        } else {
            printf("✗ Failed to get events: %s\n", etherlink_error_string(result));
        }

        etherlink_event_monitor_free(monitor);
    } else {
        printf("✗ Failed to start event monitoring\n");
    }

    etherlink_bridge_free(bridge);
    etherlink_runtime_free(runtime);
}
```

## C++ Wrapper

### Modern C++ Wrapper

```cpp
// etherlink.hpp
#ifndef ETHERLINK_HPP
#define ETHERLINK_HPP

#include <string>
#include <vector>
#include <memory>
#include <stdexcept>
#include <array>
#include <optional>
#include <cstring>
#include "etherlink.h"

namespace etherlink {

class EtherLinkError : public std::runtime_error {
public:
    explicit EtherLinkError(int error_code)
        : std::runtime_error(etherlink_error_string(error_code))
        , code_(error_code) {}

    int code() const { return code_; }

private:
    int code_;
};

// Helper class for Ethereum addresses
class Address {
public:
    Address() { data_.fill(0); }

    explicit Address(const std::array<uint8_t, 20>& bytes) : data_(bytes) {}

    static Address from_hex(const std::string& hex_string) {
        Address addr;
        int result = etherlink_address_from_hex(hex_string.c_str(), addr.data_.data());
        if (result != ETHERLINK_SUCCESS) {
            throw EtherLinkError(result);
        }
        return addr;
    }

    const std::array<uint8_t, 20>& bytes() const { return data_; }

    std::string to_hex() const {
        char hex_string[43];
        int result = etherlink_address_to_hex(data_.data(), hex_string, sizeof(hex_string));
        if (result != ETHERLINK_SUCCESS) {
            throw EtherLinkError(result);
        }
        return std::string(hex_string);
    }

private:
    std::array<uint8_t, 20> data_;
};

// Helper class for 256-bit integers
class U256 {
public:
    U256() { data_.fill(0); }

    explicit U256(uint64_t value) {
        data_.fill(0);
        // Store in big-endian format
        for (int i = 7; i >= 0; --i) {
            data_[24 + i] = static_cast<uint8_t>(value & 0xFF);
            value >>= 8;
        }
    }

    explicit U256(const std::array<uint8_t, 32>& bytes) : data_(bytes) {}

    const std::array<uint8_t, 32>& bytes() const { return data_; }

    uint64_t to_u64() const {
        uint64_t result = 0;
        for (int i = 0; i < 8; ++i) {
            result = (result << 8) | data_[24 + i];
        }
        return result;
    }

    std::string to_hex() const {
        std::string result = "0x";
        for (const auto& byte : data_) {
            char buf[3];
            snprintf(buf, sizeof(buf), "%02x", byte);
            result += buf;
        }
        return result;
    }

private:
    std::array<uint8_t, 32> data_;
};

enum class OperationType {
    Deposit = ETHERLINK_OP_DEPOSIT,
    Withdrawal = ETHERLINK_OP_WITHDRAWAL,
    Claim = ETHERLINK_OP_CLAIM,
};

enum class OperationStatus {
    Pending = ETHERLINK_STATUS_PENDING,
    Confirmed = ETHERLINK_STATUS_CONFIRMED,
    Executed = ETHERLINK_STATUS_EXECUTED,
    Failed = ETHERLINK_STATUS_FAILED,
    Cancelled = ETHERLINK_STATUS_CANCELLED,
};

enum class EventType {
    Deposit = ETHERLINK_EVENT_DEPOSIT,
    Withdrawal = ETHERLINK_EVENT_WITHDRAWAL,
    Claim = ETHERLINK_EVENT_CLAIM,
    Refund = ETHERLINK_EVENT_REFUND,
};

struct BridgeStats {
    uint64_t total_deposits;
    uint64_t total_withdrawals;
    U256 total_volume_eth;
    U256 total_volume_ghost;
    uint32_t active_deposits;
    uint32_t active_withdrawals;
    uint64_t last_processed_block;

    static BridgeStats from_native(const etherlink_stats_t& native) {
        std::array<uint8_t, 32> eth_volume_bytes;
        std::array<uint8_t, 32> ghost_volume_bytes;
        std::copy(native.total_volume_eth, native.total_volume_eth + 32, eth_volume_bytes.begin());
        std::copy(native.total_volume_ghost, native.total_volume_ghost + 32, ghost_volume_bytes.begin());

        return BridgeStats{
            .total_deposits = native.total_deposits,
            .total_withdrawals = native.total_withdrawals,
            .total_volume_eth = U256(eth_volume_bytes),
            .total_volume_ghost = U256(ghost_volume_bytes),
            .active_deposits = native.active_deposits,
            .active_withdrawals = native.active_withdrawals,
            .last_processed_block = native.last_processed_block,
        };
    }
};

struct TokenInfo {
    Address address;
    std::string symbol;
    std::string name;
    uint8_t decimals;
    bool is_mintable;
    U256 total_bridged;

    static TokenInfo from_native(const etherlink_token_info_t& native) {
        std::array<uint8_t, 20> addr_bytes;
        std::array<uint8_t, 32> bridged_bytes;
        std::copy(native.address, native.address + 20, addr_bytes.begin());
        std::copy(native.total_bridged, native.total_bridged + 32, bridged_bytes.begin());

        return TokenInfo{
            .address = Address(addr_bytes),
            .symbol = std::string(native.symbol),
            .name = std::string(native.name),
            .decimals = native.decimals,
            .is_mintable = native.is_mintable != 0,
            .total_bridged = U256(bridged_bytes),
        };
    }
};

struct DepositRequest {
    Address from_address;
    std::string to_address; // GhostChain address
    U256 amount;
    Address token_address; // 0x0 for ETH
    std::vector<uint8_t> data;
    uint64_t gas_limit;

    etherlink_deposit_request_t to_native() const {
        etherlink_deposit_request_t native{};
        std::copy(from_address.bytes().begin(), from_address.bytes().end(), native.from_address);
        strncpy(native.to_address, to_address.c_str(), 63);
        std::copy(amount.bytes().begin(), amount.bytes().end(), native.amount);
        std::copy(token_address.bytes().begin(), token_address.bytes().end(), native.token_address);
        native.data = data.empty() ? nullptr : data.data();
        native.data_len = data.size();
        native.gas_limit = gas_limit;
        return native;
    }
};

struct WithdrawalRequest {
    std::string from_address; // GhostChain address
    Address to_address;
    U256 amount;
    Address token_address; // 0x0 for ETH
    uint64_t nonce;
    std::array<uint8_t, 65> signature; // ECDSA signature

    etherlink_withdrawal_request_t to_native() const {
        etherlink_withdrawal_request_t native{};
        strncpy(native.from_address, from_address.c_str(), 63);
        std::copy(to_address.bytes().begin(), to_address.bytes().end(), native.to_address);
        std::copy(amount.bytes().begin(), amount.bytes().end(), native.amount);
        std::copy(token_address.bytes().begin(), token_address.bytes().end(), native.token_address);
        native.nonce = nonce;
        std::copy(signature.begin(), signature.end(), native.signature);
        return native;
    }
};

struct OperationInfo {
    std::string operation_id;
    OperationType operation_type;
    OperationStatus status;
    std::optional<std::string> eth_tx_hash;
    std::optional<std::string> ghost_tx_hash;
    uint32_t confirmations;
    uint32_t required_confirmations;
    uint64_t created_at;
    uint64_t updated_at;
    std::optional<std::string> error_message;

    static OperationInfo from_native(const etherlink_operation_status_t& native) {
        return OperationInfo{
            .operation_id = std::string(native.operation_id),
            .operation_type = static_cast<OperationType>(native.operation_type),
            .status = static_cast<OperationStatus>(native.status),
            .eth_tx_hash = strlen(native.eth_tx_hash) > 0 ?
                std::optional<std::string>(native.eth_tx_hash) : std::nullopt,
            .ghost_tx_hash = strlen(native.ghost_tx_hash) > 0 ?
                std::optional<std::string>(native.ghost_tx_hash) : std::nullopt,
            .confirmations = native.confirmations,
            .required_confirmations = native.required_confirmations,
            .created_at = native.created_at,
            .updated_at = native.updated_at,
            .error_message = strlen(native.error_message) > 0 ?
                std::optional<std::string>(native.error_message) : std::nullopt,
        };
    }
};

struct BridgeEvent {
    EventType event_type;
    uint64_t block_number;
    std::string transaction_hash;
    uint32_t log_index;
    Address from_address;
    Address to_address;
    U256 amount;
    size_t data_size;

    static BridgeEvent from_native(const etherlink_event_t& native) {
        std::array<uint8_t, 20> from_bytes;
        std::array<uint8_t, 20> to_bytes;
        std::array<uint8_t, 32> amount_bytes;

        std::copy(native.from_address, native.from_address + 20, from_bytes.begin());
        std::copy(native.to_address, native.to_address + 20, to_bytes.begin());
        std::copy(native.amount, native.amount + 32, amount_bytes.begin());

        return BridgeEvent{
            .event_type = static_cast<EventType>(native.event_type),
            .block_number = native.block_number,
            .transaction_hash = std::string(native.transaction_hash),
            .log_index = native.log_index,
            .from_address = Address(from_bytes),
            .to_address = Address(to_bytes),
            .amount = U256(amount_bytes),
            .data_size = native.data_size,
        };
    }
};

class Config {
public:
    Config() = default;

    Config& ethereum_rpc(const std::string& url) {
        ethereum_rpc_url_ = url;
        return *this;
    }

    Config& ethereum_ws(const std::string& url) {
        ethereum_ws_url_ = url;
        return *this;
    }

    Config& ghostchain_rpc(const std::string& url) {
        ghostchain_rpc_url_ = url;
        return *this;
    }

    Config& bridge_contract(const Address& address) {
        bridge_contract_address_ = address;
        return *this;
    }

    Config& validator_key(const std::array<uint8_t, 32>& key) {
        validator_private_key_ = key;
        return *this;
    }

    Config& confirmation_blocks(uint32_t blocks) {
        confirmation_blocks_ = blocks;
        return *this;
    }

    Config& gas_limit(uint64_t limit) {
        gas_limit_ = limit;
        return *this;
    }

    Config& gas_price_gwei(uint64_t price) {
        gas_price_gwei_ = price;
        return *this;
    }

    Config& enable_monitoring(bool enable) {
        enable_monitoring_ = enable;
        return *this;
    }

    etherlink_config_t to_native() const {
        return etherlink_config_t{
            .ethereum_rpc_url = ethereum_rpc_url_.c_str(),
            .ethereum_ws_url = ethereum_ws_url_.empty() ? nullptr : ethereum_ws_url_.c_str(),
            .ghostchain_rpc_url = ghostchain_rpc_url_.c_str(),
            .bridge_contract_address = {},
            .validator_private_key = {},
            .confirmation_blocks = confirmation_blocks_,
            .gas_limit = gas_limit_,
            .gas_price_gwei = gas_price_gwei_,
            .enable_monitoring = enable_monitoring_ ? 1 : 0,
        };
    }

private:
    std::string ethereum_rpc_url_;
    std::string ethereum_ws_url_;
    std::string ghostchain_rpc_url_;
    Address bridge_contract_address_;
    std::array<uint8_t, 32> validator_private_key_{};
    uint32_t confirmation_blocks_ = 12;
    uint64_t gas_limit_ = 300000;
    uint64_t gas_price_gwei_ = 20;
    bool enable_monitoring_ = true;
};

class Runtime {
public:
    Runtime() : runtime_(etherlink_runtime_new()) {
        if (!runtime_) {
            throw EtherLinkError(ETHERLINK_ERROR_OUT_OF_MEMORY);
        }
    }

    ~Runtime() {
        if (runtime_) {
            etherlink_runtime_free(runtime_);
        }
    }

    // Non-copyable
    Runtime(const Runtime&) = delete;
    Runtime& operator=(const Runtime&) = delete;

    // Movable
    Runtime(Runtime&& other) noexcept : runtime_(other.runtime_) {
        other.runtime_ = nullptr;
    }

    Runtime& operator=(Runtime&& other) noexcept {
        if (this != &other) {
            if (runtime_) {
                etherlink_runtime_free(runtime_);
            }
            runtime_ = other.runtime_;
            other.runtime_ = nullptr;
        }
        return *this;
    }

    etherlink_runtime_t* native() const { return runtime_; }

private:
    etherlink_runtime_t* runtime_;
};

class Deposit {
public:
    explicit Deposit(etherlink_deposit_t* deposit) : deposit_(deposit) {}

    ~Deposit() {
        if (deposit_) {
            etherlink_deposit_free(deposit_);
        }
    }

    // Non-copyable
    Deposit(const Deposit&) = delete;
    Deposit& operator=(const Deposit&) = delete;

    // Movable
    Deposit(Deposit&& other) noexcept : deposit_(other.deposit_) {
        other.deposit_ = nullptr;
    }

    Deposit& operator=(Deposit&& other) noexcept {
        if (this != &other) {
            if (deposit_) {
                etherlink_deposit_free(deposit_);
            }
            deposit_ = other.deposit_;
            other.deposit_ = nullptr;
        }
        return *this;
    }

    etherlink_deposit_t* native() const { return deposit_; }

private:
    etherlink_deposit_t* deposit_;
};

class Withdrawal {
public:
    explicit Withdrawal(etherlink_withdrawal_t* withdrawal) : withdrawal_(withdrawal) {}

    ~Withdrawal() {
        if (withdrawal_) {
            etherlink_withdrawal_free(withdrawal_);
        }
    }

    // Non-copyable
    Withdrawal(const Withdrawal&) = delete;
    Withdrawal& operator=(const Withdrawal&) = delete;

    // Movable
    Withdrawal(Withdrawal&& other) noexcept : withdrawal_(other.withdrawal_) {
        other.withdrawal_ = nullptr;
    }

    Withdrawal& operator=(Withdrawal&& other) noexcept {
        if (this != &other) {
            if (withdrawal_) {
                etherlink_withdrawal_free(withdrawal_);
            }
            withdrawal_ = other.withdrawal_;
            other.withdrawal_ = nullptr;
        }
        return *this;
    }

    etherlink_withdrawal_t* native() const { return withdrawal_; }

private:
    etherlink_withdrawal_t* withdrawal_;
};

class EventMonitor {
public:
    explicit EventMonitor(etherlink_event_monitor_t* monitor) : monitor_(monitor) {}

    ~EventMonitor() {
        if (monitor_) {
            etherlink_event_monitor_free(monitor_);
        }
    }

    // Non-copyable
    EventMonitor(const EventMonitor&) = delete;
    EventMonitor& operator=(const EventMonitor&) = delete;

    // Movable
    EventMonitor(EventMonitor&& other) noexcept : monitor_(other.monitor_) {
        other.monitor_ = nullptr;
    }

    EventMonitor& operator=(EventMonitor&& other) noexcept {
        if (this != &other) {
            if (monitor_) {
                etherlink_event_monitor_free(monitor_);
            }
            monitor_ = other.monitor_;
            other.monitor_ = nullptr;
        }
        return *this;
    }

    std::vector<BridgeEvent> get_recent_events(size_t max_events = 100) const {
        std::vector<etherlink_event_t> native_events(max_events);
        size_t actual_count;

        int result = etherlink_get_recent_events(
            monitor_,
            native_events.data(),
            max_events,
            &actual_count
        );

        if (result != ETHERLINK_SUCCESS) {
            throw EtherLinkError(result);
        }

        std::vector<BridgeEvent> events;
        events.reserve(actual_count);

        for (size_t i = 0; i < actual_count; ++i) {
            events.push_back(BridgeEvent::from_native(native_events[i]));
        }

        return events;
    }

private:
    etherlink_event_monitor_t* monitor_;
};

class Bridge {
public:
    Bridge(Runtime& runtime, const Config& config = Config{})
        : bridge_(etherlink_bridge_new(runtime.native(), &config.to_native())) {
        if (!bridge_) {
            throw EtherLinkError(ETHERLINK_ERROR_CONNECTION_FAILED);
        }
    }

    ~Bridge() {
        if (bridge_) {
            etherlink_bridge_free(bridge_);
        }
    }

    // Non-copyable
    Bridge(const Bridge&) = delete;
    Bridge& operator=(const Bridge&) = delete;

    // Movable
    Bridge(Bridge&& other) noexcept : bridge_(other.bridge_) {
        other.bridge_ = nullptr;
    }

    Bridge& operator=(Bridge&& other) noexcept {
        if (this != &other) {
            if (bridge_) {
                etherlink_bridge_free(bridge_);
            }
            bridge_ = other.bridge_;
            other.bridge_ = nullptr;
        }
        return *this;
    }

    BridgeStats get_stats() const {
        etherlink_stats_t stats;
        int result = etherlink_get_bridge_stats(bridge_, &stats);
        if (result != ETHERLINK_SUCCESS) {
            throw EtherLinkError(result);
        }
        return BridgeStats::from_native(stats);
    }

    std::vector<TokenInfo> get_supported_tokens() const {
        etherlink_token_info_t tokens[50];
        size_t actual_count;

        int result = etherlink_get_supported_tokens(bridge_, tokens, 50, &actual_count);
        if (result != ETHERLINK_SUCCESS) {
            throw EtherLinkError(result);
        }

        std::vector<TokenInfo> token_list;
        token_list.reserve(actual_count);

        for (size_t i = 0; i < actual_count; ++i) {
            token_list.push_back(TokenInfo::from_native(tokens[i]));
        }

        return token_list;
    }

    std::unique_ptr<Deposit> create_deposit(const DepositRequest& request) {
        auto native_request = request.to_native();
        etherlink_deposit_t* deposit = etherlink_create_deposit(bridge_, &native_request);

        if (!deposit) {
            throw EtherLinkError(ETHERLINK_ERROR_TRANSACTION_FAILED);
        }

        return std::make_unique<Deposit>(deposit);
    }

    void submit_deposit(Deposit& deposit) {
        int result = etherlink_submit_deposit(bridge_, deposit.native());
        if (result != ETHERLINK_SUCCESS) {
            throw EtherLinkError(result);
        }
    }

    std::unique_ptr<Withdrawal> create_withdrawal(const WithdrawalRequest& request) {
        auto native_request = request.to_native();
        etherlink_withdrawal_t* withdrawal = etherlink_create_withdrawal(bridge_, &native_request);

        if (!withdrawal) {
            throw EtherLinkError(ETHERLINK_ERROR_TRANSACTION_FAILED);
        }

        return std::make_unique<Withdrawal>(withdrawal);
    }

    void submit_withdrawal(Withdrawal& withdrawal) {
        int result = etherlink_submit_withdrawal(bridge_, withdrawal.native());
        if (result != ETHERLINK_SUCCESS) {
            throw EtherLinkError(result);
        }
    }

    OperationInfo get_operation_status(const std::string& operation_id) const {
        etherlink_operation_status_t status;
        int result = etherlink_get_operation_status(bridge_, operation_id.c_str(), &status);
        if (result != ETHERLINK_SUCCESS) {
            throw EtherLinkError(result);
        }
        return OperationInfo::from_native(status);
    }

    std::unique_ptr<EventMonitor> start_event_monitoring() {
        etherlink_event_monitor_t* monitor = etherlink_start_event_monitoring(bridge_);
        if (!monitor) {
            throw EtherLinkError(ETHERLINK_ERROR_CONNECTION_FAILED);
        }
        return std::make_unique<EventMonitor>(monitor);
    }

private:
    etherlink_bridge_t* bridge_;
};

// Utility functions
inline std::string version() {
    return std::string(etherlink_version_string());
}

inline std::string operation_type_name(OperationType op_type) {
    return std::string(etherlink_operation_type_name(static_cast<int>(op_type)));
}

inline std::string status_name(OperationStatus status) {
    return std::string(etherlink_status_name(static_cast<int>(status)));
}

} // namespace etherlink

#endif // ETHERLINK_HPP
```

### C++ Usage Example

```cpp
// example.cpp
#include <iostream>
#include <iomanip>
#include <thread>
#include <chrono>
#include "etherlink.hpp"

void test_bridge_setup();
void test_deposit_flow();
void test_withdrawal_flow();
void test_event_monitoring();

int main() {
    try {
        std::cout << "EtherLink version: " << etherlink::version() << std::endl;

        test_bridge_setup();
        test_deposit_flow();
        test_withdrawal_flow();
        test_event_monitoring();

    } catch (const etherlink::EtherLinkError& e) {
        std::cerr << "EtherLink error: " << e.what() << " (code: " << e.code() << ")" << std::endl;
        return 1;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    std::cout << "All EtherLink tests completed!" << std::endl;
    return 0;
}

void test_bridge_setup() {
    std::cout << "\n=== Bridge Setup Test ===" << std::endl;

    etherlink::Runtime runtime;

    etherlink::Config config;
    config.ethereum_rpc("https://goerli.infura.io/v3/YOUR_KEY")
          .ethereum_ws("wss://goerli.infura.io/ws/v3/YOUR_KEY")
          .ghostchain_rpc("https://testnet-rpc.ghostchain.io")
          .bridge_contract(etherlink::Address::from_hex("0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B"))
          .confirmation_blocks(3)
          .gas_limit(300000)
          .gas_price_gwei(20)
          .enable_monitoring(true);

    etherlink::Bridge bridge(runtime, config);
    std::cout << "✓ Bridge initialized successfully" << std::endl;

    // Get bridge statistics
    auto stats = bridge.get_stats();
    std::cout << "✓ Bridge statistics:" << std::endl;
    std::cout << "  - Total deposits: " << stats.total_deposits << std::endl;
    std::cout << "  - Total withdrawals: " << stats.total_withdrawals << std::endl;
    std::cout << "  - Active operations: " << (stats.active_deposits + stats.active_withdrawals) << std::endl;
    std::cout << "  - ETH volume: " << stats.total_volume_eth.to_hex() << std::endl;

    // Get supported tokens
    auto tokens = bridge.get_supported_tokens();
    std::cout << "✓ Supported tokens (" << tokens.size() << "):" << std::endl;
    for (const auto& token : tokens) {
        std::cout << "  - " << token.symbol << " (" << token.name << "): "
                  << token.address.to_hex() << std::endl;
        std::cout << "    Decimals: " << static_cast<int>(token.decimals)
                  << ", Mintable: " << (token.is_mintable ? "Yes" : "No") << std::endl;
    }
}

void test_deposit_flow() {
    std::cout << "\n=== Deposit Flow Test ===" << std::endl;

    etherlink::Runtime runtime;
    etherlink::Config config;
    config.ethereum_rpc("https://goerli.infura.io/v3/YOUR_KEY")
          .ghostchain_rpc("https://testnet-rpc.ghostchain.io");

    etherlink::Bridge bridge(runtime, config);

    // Create deposit request
    etherlink::DepositRequest deposit_request{
        .from_address = etherlink::Address::from_hex("0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B"),
        .to_address = "ghost1abcd1234567890abcd1234567890abcd123456",
        .amount = etherlink::U256(1000000000000000000ULL), // 1 ETH
        .token_address = etherlink::Address(), // ETH (0x0)
        .data = {},
        .gas_limit = 100000,
    };

    try {
        // Create and submit deposit
        auto deposit = bridge.create_deposit(deposit_request);
        std::cout << "✓ Deposit created successfully" << std::endl;

        bridge.submit_deposit(*deposit);
        std::cout << "✓ Deposit submitted to Ethereum network" << std::endl;

        // In a real application, you would get the operation ID from the response
        std::cout << "✓ Monitor operation status for completion" << std::endl;

    } catch (const etherlink::EtherLinkError& e) {
        std::cout << "✗ Deposit failed: " << e.what() << std::endl;
    }
}

void test_withdrawal_flow() {
    std::cout << "\n=== Withdrawal Flow Test ===" << std::endl;

    etherlink::Runtime runtime;
    etherlink::Config config;
    config.ethereum_rpc("https://goerli.infura.io/v3/YOUR_KEY")
          .ghostchain_rpc("https://testnet-rpc.ghostchain.io");

    etherlink::Bridge bridge(runtime, config);

    // Create withdrawal request
    std::array<uint8_t, 65> signature;
    signature.fill(0x12); // Example signature - would be real in practice

    etherlink::WithdrawalRequest withdrawal_request{
        .from_address = "ghost1abcd1234567890abcd1234567890abcd123456",
        .to_address = etherlink::Address::from_hex("0x742d35Cc6634C0532925a3b8D431Df45C3f8D23B"),
        .amount = etherlink::U256(500000000000000000ULL), // 0.5 ETH
        .token_address = etherlink::Address(), // ETH (0x0)
        .nonce = 1,
        .signature = signature,
    };

    try {
        // Create and submit withdrawal
        auto withdrawal = bridge.create_withdrawal(withdrawal_request);
        std::cout << "✓ Withdrawal created successfully" << std::endl;

        bridge.submit_withdrawal(*withdrawal);
        std::cout << "✓ Withdrawal submitted to Ethereum network" << std::endl;

        // Check operation status
        try {
            auto status = bridge.get_operation_status("example_withdrawal_id");
            std::cout << "✓ Operation status:" << std::endl;
            std::cout << "  - Type: " << etherlink::operation_type_name(status.operation_type) << std::endl;
            std::cout << "  - Status: " << etherlink::status_name(status.status) << std::endl;
            std::cout << "  - Confirmations: " << status.confirmations
                      << "/" << status.required_confirmations << std::endl;

            if (status.eth_tx_hash) {
                std::cout << "  - Ethereum TX: " << *status.eth_tx_hash << std::endl;
            }
            if (status.error_message) {
                std::cout << "  - Error: " << *status.error_message << std::endl;
            }
        } catch (const etherlink::EtherLinkError& e) {
            std::cout << "✗ Status check failed: " << e.what() << std::endl;
        }

    } catch (const etherlink::EtherLinkError& e) {
        std::cout << "✗ Withdrawal failed: " << e.what() << std::endl;
    }
}

void test_event_monitoring() {
    std::cout << "\n=== Event Monitoring Test ===" << std::endl;

    etherlink::Runtime runtime;
    etherlink::Config config;
    config.ethereum_rpc("https://mainnet.infura.io/v3/YOUR_KEY")
          .ethereum_ws("wss://mainnet.infura.io/ws/v3/YOUR_KEY")
          .ghostchain_rpc("https://rpc.ghostchain.io")
          .enable_monitoring(true);

    etherlink::Bridge bridge(runtime, config);

    try {
        // Start event monitoring
        auto monitor = bridge.start_event_monitoring();
        std::cout << "✓ Event monitoring started" << std::endl;

        // Get recent events
        auto events = monitor->get_recent_events(50);
        std::cout << "✓ Retrieved " << events.size() << " recent events" << std::endl;

        for (size_t i = 0; i < events.size(); ++i) {
            const auto& event = events[i];
            std::cout << "  Event " << (i + 1) << ":" << std::endl;

            std::string event_type_name;
            switch (event.event_type) {
                case etherlink::EventType::Deposit: event_type_name = "Deposit"; break;
                case etherlink::EventType::Withdrawal: event_type_name = "Withdrawal"; break;
                case etherlink::EventType::Claim: event_type_name = "Claim"; break;
                case etherlink::EventType::Refund: event_type_name = "Refund"; break;
            }

            std::cout << "    - Type: " << event_type_name << std::endl;
            std::cout << "    - Block: " << event.block_number << std::endl;
            std::cout << "    - TX Hash: " << event.transaction_hash << std::endl;
            std::cout << "    - From: " << event.from_address.to_hex() << std::endl;
            std::cout << "    - To: " << event.to_address.to_hex() << std::endl;
            std::cout << "    - Amount: " << event.amount.to_hex() << std::endl;

            if (i >= 4) { // Show only first 5 events
                std::cout << "    ... and " << (events.size() - 5) << " more events" << std::endl;
                break;
            }
        }

        // Simulate monitoring for a short time
        std::cout << "✓ Monitoring events for 5 seconds..." << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(5));

        // Get any new events
        auto new_events = monitor->get_recent_events(10);
        if (new_events.size() > events.size()) {
            std::cout << "✓ Detected " << (new_events.size() - events.size())
                      << " new events during monitoring" << std::endl;
        }

    } catch (const etherlink::EtherLinkError& e) {
        std::cout << "✗ Event monitoring failed: " << e.what() << std::endl;
    }
}
```

## CMake Integration

### CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.15)
project(etherlink_example)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find the EtherLink library
find_library(ETHERLINK_LIBRARY
    NAMES etherlink_c
    PATHS ${CMAKE_SOURCE_DIR}/target/release
    REQUIRED
)

# Find the EtherLink headers
find_path(ETHERLINK_INCLUDE_DIR
    NAMES etherlink.h
    PATHS ${CMAKE_SOURCE_DIR}/include
    REQUIRED
)

# Create imported target
add_library(etherlink::etherlink UNKNOWN IMPORTED)
set_target_properties(etherlink::etherlink PROPERTIES
    IMPORTED_LOCATION ${ETHERLINK_LIBRARY}
    INTERFACE_INCLUDE_DIRECTORIES ${ETHERLINK_INCLUDE_DIR}
)

# C example
add_executable(c_bridge bridge_example.c)
target_link_libraries(c_bridge
    etherlink::etherlink
    pthread
    dl
    m
)

# C++ example
add_executable(cpp_bridge example.cpp)
target_link_libraries(cpp_bridge
    etherlink::etherlink
    pthread
    dl
    m
)

# Custom target to build Rust library
add_custom_target(build_rust_lib
    COMMAND cargo build --release
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    COMMENT "Building Rust EtherLink library"
)

# Make sure Rust library is built before our targets
add_dependencies(c_bridge build_rust_lib)
add_dependencies(cpp_bridge build_rust_lib)
```

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "Double-check gcrypt gcc-docs completeness", "status": "completed", "activeForm": "Double-checking gcrypt gcc-docs completeness"}, {"content": "Create gcc-docs for gquic project", "status": "completed", "activeForm": "Creating gcc-docs for gquic project"}, {"content": "Create gcc-docs for ghostbridge project", "status": "completed", "activeForm": "Creating gcc-docs for ghostbridge project"}, {"content": "Create gcc-docs for rvm project", "status": "completed", "activeForm": "Creating gcc-docs for rvm project"}, {"content": "Create gcc-docs for etherlink project", "status": "completed", "activeForm": "Creating gcc-docs for etherlink project"}]