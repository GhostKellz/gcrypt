# Zig Integration Guide

Complete guide for using gcrypt from Zig projects via C FFI bindings.

## Table of Contents

- [Quick Start](#quick-start)
- [C Bindings Setup](#c-bindings-setup)
- [Basic Usage](#basic-usage)
- [Advanced Patterns](#advanced-patterns)
- [Memory Management](#memory-management)
- [Error Handling](#error-handling)
- [Performance Tips](#performance-tips)

## Quick Start

### Dependencies

First, add gcrypt to your Rust project with C bindings:

```toml
# Cargo.toml
[lib]
name = "gcrypt_c"
crate-type = ["cdylib", "staticlib"]

[dependencies]
gcrypt = { version = "0.2", features = ["std", "rand_core"] }
libc = "0.2"

[build-dependencies]
cbindgen = "0.24"
```

### C Header Generation

Create `build.rs` to generate C headers:

```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let package_name = env::var("CARGO_PKG_NAME").unwrap();
    let output_file = PathBuf::from(&crate_dir)
        .join("target")
        .join("include")
        .join(format!("{}.h", package_name));

    std::fs::create_dir_all(output_file.parent().unwrap()).unwrap();

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("GCRYPT_H")
        .with_autogen_warning("/* Warning: This file is autogenerated by cbindgen. */")
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(&output_file);

    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=cbindgen.toml");
}
```

## C Bindings Setup

### Rust C API Implementation

```rust
// src/lib.rs
use gcrypt::protocols::{Ed25519, X25519};
use std::ptr;
use std::slice;
use libc::{c_int, c_char, size_t};

// Error codes
pub const GCRYPT_SUCCESS: c_int = 0;
pub const GCRYPT_ERROR_INVALID_INPUT: c_int = -1;
pub const GCRYPT_ERROR_VERIFICATION_FAILED: c_int = -2;
pub const GCRYPT_ERROR_GENERATION_FAILED: c_int = -3;
pub const GCRYPT_ERROR_KEY_EXCHANGE_FAILED: c_int = -4;

// Type definitions for C
#[repr(C)]
pub struct Ed25519SecretKey {
    data: [u8; 32],
}

#[repr(C)]
pub struct Ed25519PublicKey {
    data: [u8; 32],
}

#[repr(C)]
pub struct Ed25519Signature {
    data: [u8; 64],
}

#[repr(C)]
pub struct X25519SecretKey {
    data: [u8; 32],
}

#[repr(C)]
pub struct X25519PublicKey {
    data: [u8; 32],
}

#[repr(C)]
pub struct X25519SharedSecret {
    data: [u8; 32],
}

// Ed25519 Functions
#[no_mangle]
pub extern "C" fn ed25519_generate_keypair(
    secret_key: *mut Ed25519SecretKey,
    public_key: *mut Ed25519PublicKey,
) -> c_int {
    if secret_key.is_null() || public_key.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let mut rng = rand::rngs::OsRng;
    let sk = Ed25519::SecretKey::generate(&mut rng);
    let pk = sk.public_key();

    unsafe {
        (*secret_key).data = sk.to_bytes();
        (*public_key).data = pk.to_bytes();
    }

    GCRYPT_SUCCESS
}

#[no_mangle]
pub extern "C" fn ed25519_sign(
    secret_key: *const Ed25519SecretKey,
    message: *const u8,
    message_len: size_t,
    signature: *mut Ed25519Signature,
) -> c_int {
    if secret_key.is_null() || message.is_null() || signature.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let sk_bytes = unsafe { (*secret_key).data };
    let sk = Ed25519::SecretKey::from_bytes(&sk_bytes);
    
    let msg_slice = unsafe { slice::from_raw_parts(message, message_len) };
    let sig = sk.sign_deterministic(msg_slice);

    unsafe {
        (*signature).data = sig.to_bytes();
    }

    GCRYPT_SUCCESS
}

#[no_mangle]
pub extern "C" fn ed25519_verify(
    public_key: *const Ed25519PublicKey,
    message: *const u8,
    message_len: size_t,
    signature: *const Ed25519Signature,
) -> c_int {
    if public_key.is_null() || message.is_null() || signature.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let pk_bytes = unsafe { (*public_key).data };
    let pk = match Ed25519::PublicKey::from_bytes(&pk_bytes) {
        Ok(pk) => pk,
        Err(_) => return GCRYPT_ERROR_INVALID_INPUT,
    };

    let sig_bytes = unsafe { (*signature).data };
    let sig = Ed25519::Signature::from_bytes(&sig_bytes);
    
    let msg_slice = unsafe { slice::from_raw_parts(message, message_len) };

    match pk.verify(msg_slice, &sig) {
        Ok(_) => GCRYPT_SUCCESS,
        Err(_) => GCRYPT_ERROR_VERIFICATION_FAILED,
    }
}

// X25519 Functions
#[no_mangle]
pub extern "C" fn x25519_generate_keypair(
    secret_key: *mut X25519SecretKey,
    public_key: *mut X25519PublicKey,
) -> c_int {
    if secret_key.is_null() || public_key.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let mut rng = rand::rngs::OsRng;
    let sk = X25519::SecretKey::generate(&mut rng);
    let pk = sk.public_key();

    unsafe {
        (*secret_key).data = sk.to_bytes();
        (*public_key).data = pk.to_bytes();
    }

    GCRYPT_SUCCESS
}

#[no_mangle]
pub extern "C" fn x25519_key_exchange(
    secret_key: *const X25519SecretKey,
    public_key: *const X25519PublicKey,
    shared_secret: *mut X25519SharedSecret,
) -> c_int {
    if secret_key.is_null() || public_key.is_null() || shared_secret.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let sk_bytes = unsafe { (*secret_key).data };
    let sk = X25519::SecretKey::from_bytes(&sk_bytes);

    let pk_bytes = unsafe { (*public_key).data };
    let pk = match X25519::PublicKey::from_bytes(&pk_bytes) {
        Ok(pk) => pk,
        Err(_) => return GCRYPT_ERROR_INVALID_INPUT,
    };

    match sk.diffie_hellman(&pk) {
        Ok(shared) => {
            unsafe {
                (*shared_secret).data = shared.to_bytes();
            }
            GCRYPT_SUCCESS
        }
        Err(_) => GCRYPT_ERROR_KEY_EXCHANGE_FAILED,
    }
}

// Utility functions
#[no_mangle]
pub extern "C" fn gcrypt_secure_zero(ptr: *mut u8, len: size_t) {
    if !ptr.is_null() && len > 0 {
        unsafe {
            let slice = slice::from_raw_parts_mut(ptr, len);
            for byte in slice {
                *byte = 0;
            }
            // In a real implementation, use secure zeroing
            std::ptr::write_volatile(&mut slice[0], 0);
        }
    }
}

#[no_mangle]
pub extern "C" fn gcrypt_version() -> *const c_char {
    "gcrypt 0.2.0\0".as_ptr() as *const c_char
}
```

### Generated C Header

The build process will generate `gcrypt_c.h`:

```c
/* Warning: This file is autogenerated by cbindgen. */

#ifndef GCRYPT_H
#define GCRYPT_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define GCRYPT_SUCCESS 0
#define GCRYPT_ERROR_INVALID_INPUT -1
#define GCRYPT_ERROR_VERIFICATION_FAILED -2
#define GCRYPT_ERROR_GENERATION_FAILED -3
#define GCRYPT_ERROR_KEY_EXCHANGE_FAILED -4

typedef struct Ed25519SecretKey {
  uint8_t data[32];
} Ed25519SecretKey;

typedef struct Ed25519PublicKey {
  uint8_t data[32];
} Ed25519PublicKey;

typedef struct Ed25519Signature {
  uint8_t data[64];
} Ed25519Signature;

typedef struct X25519SecretKey {
  uint8_t data[32];
} X25519SecretKey;

typedef struct X25519PublicKey {
  uint8_t data[32];
} X25519PublicKey;

typedef struct X25519SharedSecret {
  uint8_t data[32];
} X25519SharedSecret;

int ed25519_generate_keypair(Ed25519SecretKey *secret_key, 
                            Ed25519PublicKey *public_key);

int ed25519_sign(const Ed25519SecretKey *secret_key,
                const uint8_t *message,
                size_t message_len,
                Ed25519Signature *signature);

int ed25519_verify(const Ed25519PublicKey *public_key,
                  const uint8_t *message,
                  size_t message_len,
                  const Ed25519Signature *signature);

int x25519_generate_keypair(X25519SecretKey *secret_key,
                           X25519PublicKey *public_key);

int x25519_key_exchange(const X25519SecretKey *secret_key,
                       const X25519PublicKey *public_key,
                       X25519SharedSecret *shared_secret);

void gcrypt_secure_zero(uint8_t *ptr, size_t len);

const char *gcrypt_version(void);

#endif /* GCRYPT_H */
```

## Basic Usage

### Zig Build Configuration

```zig
// build.zig
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "gcrypt_example",
        .root_source_file = .{ .path = "src/main.zig" },
        .target = target,
        .optimize = optimize,
    });

    // Link to gcrypt C library
    exe.linkLibC();
    exe.addLibraryPath(.{ .path = "target/release" });
    exe.linkSystemLibrary("gcrypt_c");
    exe.addIncludePath(.{ .path = "target/include" });

    b.installArtifact(exe);

    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());

    const run_step = b.step("run", "Run the app");
    run_step.dependOn(&run_cmd.step);
}
```

### Basic Zig Usage

```zig
// src/main.zig
const std = @import("std");
const print = std.debug.print;

const gcrypt = @cImport({
    @cInclude("gcrypt_c.h");
});

pub fn main() !void {
    print("gcrypt version: {s}\n", gcrypt.gcrypt_version());

    // Test Ed25519 signature
    try test_ed25519_signature();
    
    // Test X25519 key exchange
    try test_x25519_exchange();
}

fn test_ed25519_signature() !void {
    var secret_key: gcrypt.Ed25519SecretKey = undefined;
    var public_key: gcrypt.Ed25519PublicKey = undefined;
    var signature: gcrypt.Ed25519Signature = undefined;

    // Generate key pair
    var result = gcrypt.ed25519_generate_keypair(&secret_key, &public_key);
    if (result != gcrypt.GCRYPT_SUCCESS) {
        return error.KeyGenerationFailed;
    }

    // Sign a message
    const message = "Hello from Zig!";
    result = gcrypt.ed25519_sign(
        &secret_key,
        message.ptr,
        message.len,
        &signature
    );
    if (result != gcrypt.GCRYPT_SUCCESS) {
        return error.SigningFailed;
    }

    // Verify signature
    result = gcrypt.ed25519_verify(
        &public_key,
        message.ptr,
        message.len,
        &signature
    );
    if (result != gcrypt.GCRYPT_SUCCESS) {
        return error.VerificationFailed;
    }

    print("✓ Ed25519 signature test passed\n");

    // Clear sensitive data
    gcrypt.gcrypt_secure_zero(@ptrCast(&secret_key), @sizeOf(gcrypt.Ed25519SecretKey));
}

fn test_x25519_exchange() !void {
    var alice_secret: gcrypt.X25519SecretKey = undefined;
    var alice_public: gcrypt.X25519PublicKey = undefined;
    var bob_secret: gcrypt.X25519SecretKey = undefined;
    var bob_public: gcrypt.X25519PublicKey = undefined;

    // Generate Alice's key pair
    var result = gcrypt.x25519_generate_keypair(&alice_secret, &alice_public);
    if (result != gcrypt.GCRYPT_SUCCESS) {
        return error.KeyGenerationFailed;
    }

    // Generate Bob's key pair
    result = gcrypt.x25519_generate_keypair(&bob_secret, &bob_public);
    if (result != gcrypt.GCRYPT_SUCCESS) {
        return error.KeyGenerationFailed;
    }

    // Alice computes shared secret
    var alice_shared: gcrypt.X25519SharedSecret = undefined;
    result = gcrypt.x25519_key_exchange(&alice_secret, &bob_public, &alice_shared);
    if (result != gcrypt.GCRYPT_SUCCESS) {
        return error.KeyExchangeFailed;
    }

    // Bob computes shared secret
    var bob_shared: gcrypt.X25519SharedSecret = undefined;
    result = gcrypt.x25519_key_exchange(&bob_secret, &alice_public, &bob_shared);
    if (result != gcrypt.GCRYPT_SUCCESS) {
        return error.KeyExchangeFailed;
    }

    // Verify shared secrets match
    if (!std.mem.eql(u8, &alice_shared.data, &bob_shared.data)) {
        return error.SharedSecretMismatch;
    }

    print("✓ X25519 key exchange test passed\n");

    // Clear sensitive data
    gcrypt.gcrypt_secure_zero(@ptrCast(&alice_secret), @sizeOf(gcrypt.X25519SecretKey));
    gcrypt.gcrypt_secure_zero(@ptrCast(&bob_secret), @sizeOf(gcrypt.X25519SecretKey));
    gcrypt.gcrypt_secure_zero(@ptrCast(&alice_shared), @sizeOf(gcrypt.X25519SharedSecret));
    gcrypt.gcrypt_secure_zero(@ptrCast(&bob_shared), @sizeOf(gcrypt.X25519SharedSecret));
}
```

## Advanced Patterns

### Zig Wrapper Library

Create a more idiomatic Zig wrapper:

```zig
// src/gcrypt_zig.zig
const std = @import("std");
const Allocator = std.mem.Allocator;

const gcrypt_c = @cImport({
    @cInclude("gcrypt_c.h");
});

pub const GcryptError = error{
    InvalidInput,
    VerificationFailed,
    GenerationFailed,
    KeyExchangeFailed,
    OutOfMemory,
};

// Ed25519 wrapper
pub const Ed25519 = struct {
    pub const SecretKey = struct {
        data: [32]u8,

        pub fn generate() GcryptError!SecretKey {
            var secret_key: gcrypt_c.Ed25519SecretKey = undefined;
            var public_key: gcrypt_c.Ed25519PublicKey = undefined;

            const result = gcrypt_c.ed25519_generate_keypair(&secret_key, &public_key);
            if (result != gcrypt_c.GCRYPT_SUCCESS) {
                return GcryptError.GenerationFailed;
            }

            return SecretKey{ .data = secret_key.data };
        }

        pub fn fromBytes(bytes: [32]u8) SecretKey {
            return SecretKey{ .data = bytes };
        }

        pub fn publicKey(self: *const SecretKey) PublicKey {
            var secret_key: gcrypt_c.Ed25519SecretKey = .{ .data = self.data };
            var public_key: gcrypt_c.Ed25519PublicKey = undefined;

            _ = gcrypt_c.ed25519_generate_keypair(&secret_key, &public_key);
            return PublicKey{ .data = public_key.data };
        }

        pub fn sign(self: *const SecretKey, message: []const u8, allocator: Allocator) GcryptError!Signature {
            _ = allocator; // Signature is fixed size, no allocation needed

            var secret_key: gcrypt_c.Ed25519SecretKey = .{ .data = self.data };
            var signature: gcrypt_c.Ed25519Signature = undefined;

            const result = gcrypt_c.ed25519_sign(
                &secret_key,
                message.ptr,
                message.len,
                &signature
            );

            if (result != gcrypt_c.GCRYPT_SUCCESS) {
                return GcryptError.GenerationFailed;
            }

            return Signature{ .data = signature.data };
        }

        pub fn deinit(self: *SecretKey) void {
            gcrypt_c.gcrypt_secure_zero(&self.data, 32);
        }
    };

    pub const PublicKey = struct {
        data: [32]u8,

        pub fn fromBytes(bytes: [32]u8) GcryptError!PublicKey {
            // In a real implementation, validate the public key
            return PublicKey{ .data = bytes };
        }

        pub fn verify(self: *const PublicKey, message: []const u8, signature: *const Signature) GcryptError!void {
            var public_key: gcrypt_c.Ed25519PublicKey = .{ .data = self.data };
            var sig: gcrypt_c.Ed25519Signature = .{ .data = signature.data };

            const result = gcrypt_c.ed25519_verify(
                &public_key,
                message.ptr,
                message.len,
                &sig
            );

            if (result != gcrypt_c.GCRYPT_SUCCESS) {
                return GcryptError.VerificationFailed;
            }
        }
    };

    pub const Signature = struct {
        data: [64]u8,

        pub fn fromBytes(bytes: [64]u8) Signature {
            return Signature{ .data = bytes };
        }

        pub fn toBytes(self: *const Signature) [64]u8 {
            return self.data;
        }
    };
};

// X25519 wrapper
pub const X25519 = struct {
    pub const SecretKey = struct {
        data: [32]u8,

        pub fn generate() GcryptError!SecretKey {
            var secret_key: gcrypt_c.X25519SecretKey = undefined;
            var public_key: gcrypt_c.X25519PublicKey = undefined;

            const result = gcrypt_c.x25519_generate_keypair(&secret_key, &public_key);
            if (result != gcrypt_c.GCRYPT_SUCCESS) {
                return GcryptError.GenerationFailed;
            }

            return SecretKey{ .data = secret_key.data };
        }

        pub fn fromBytes(bytes: [32]u8) SecretKey {
            return SecretKey{ .data = bytes };
        }

        pub fn publicKey(self: *const SecretKey) PublicKey {
            var secret_key: gcrypt_c.X25519SecretKey = .{ .data = self.data };
            var public_key: gcrypt_c.X25519PublicKey = undefined;

            _ = gcrypt_c.x25519_generate_keypair(&secret_key, &public_key);
            return PublicKey{ .data = public_key.data };
        }

        pub fn exchange(self: *const SecretKey, their_public: *const PublicKey) GcryptError!SharedSecret {
            var secret_key: gcrypt_c.X25519SecretKey = .{ .data = self.data };
            var public_key: gcrypt_c.X25519PublicKey = .{ .data = their_public.data };
            var shared_secret: gcrypt_c.X25519SharedSecret = undefined;

            const result = gcrypt_c.x25519_key_exchange(&secret_key, &public_key, &shared_secret);
            if (result != gcrypt_c.GCRYPT_SUCCESS) {
                return GcryptError.KeyExchangeFailed;
            }

            return SharedSecret{ .data = shared_secret.data };
        }

        pub fn deinit(self: *SecretKey) void {
            gcrypt_c.gcrypt_secure_zero(&self.data, 32);
        }
    };

    pub const PublicKey = struct {
        data: [32]u8,

        pub fn fromBytes(bytes: [32]u8) GcryptError!PublicKey {
            return PublicKey{ .data = bytes };
        }

        pub fn toBytes(self: *const PublicKey) [32]u8 {
            return self.data;
        }
    };

    pub const SharedSecret = struct {
        data: [32]u8,

        pub fn toBytes(self: *const SharedSecret) [32]u8 {
            return self.data;
        }

        pub fn deinit(self: *SharedSecret) void {
            gcrypt_c.gcrypt_secure_zero(&self.data, 32);
        }
    };
};

// Utility functions
pub fn secureZero(buffer: []u8) void {
    gcrypt_c.gcrypt_secure_zero(buffer.ptr, buffer.len);
}

pub fn version() []const u8 {
    return std.mem.span(gcrypt_c.gcrypt_version());
}
```

### Usage with Zig Wrapper

```zig
// src/example_with_wrapper.zig
const std = @import("std");
const gcrypt = @import("gcrypt_zig.zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    print("Using gcrypt {s}\n", gcrypt.version());

    try test_ed25519_with_wrapper(allocator);
    try test_x25519_with_wrapper();
}

fn test_ed25519_with_wrapper(allocator: std.mem.Allocator) !void {
    // Generate key pair
    var secret_key = try gcrypt.Ed25519.SecretKey.generate();
    defer secret_key.deinit();

    const public_key = secret_key.publicKey();

    // Sign message
    const message = "Hello from Zig wrapper!";
    const signature = try secret_key.sign(message, allocator);

    // Verify signature
    try public_key.verify(message, &signature);

    std.debug.print("✓ Ed25519 wrapper test passed\n");
}

fn test_x25519_with_wrapper() !void {
    // Alice generates key pair
    var alice_secret = try gcrypt.X25519.SecretKey.generate();
    defer alice_secret.deinit();
    const alice_public = alice_secret.publicKey();

    // Bob generates key pair
    var bob_secret = try gcrypt.X25519.SecretKey.generate();
    defer bob_secret.deinit();
    const bob_public = bob_secret.publicKey();

    // Key exchange
    var alice_shared = try alice_secret.exchange(&bob_public);
    defer alice_shared.deinit();

    var bob_shared = try bob_secret.exchange(&alice_public);
    defer bob_shared.deinit();

    // Verify shared secrets match
    if (!std.mem.eql(u8, &alice_shared.data, &bob_shared.data)) {
        return error.SharedSecretMismatch;
    }

    std.debug.print("✓ X25519 wrapper test passed\n");
}
```

## Memory Management

### RAII Pattern in Zig

```zig
// src/secure_memory.zig
const std = @import("std");
const gcrypt = @import("gcrypt_zig.zig");

pub fn SecureBuffer(comptime T: type) type {
    return struct {
        const Self = @This();
        
        data: T,
        
        pub fn init(data: T) Self {
            return Self{ .data = data };
        }
        
        pub fn deinit(self: *Self) void {
            const bytes = std.mem.asBytes(&self.data);
            gcrypt.secureZero(bytes);
        }
        
        pub fn get(self: *const Self) *const T {
            return &self.data;
        }
        
        pub fn getMut(self: *Self) *T {
            return &self.data;
        }
    };
}

// Usage example
pub fn secure_key_example() !void {
    var secret_key_buf = SecureBuffer(gcrypt.Ed25519.SecretKey).init(
        try gcrypt.Ed25519.SecretKey.generate()
    );
    defer secret_key_buf.deinit();
    
    const secret_key = secret_key_buf.get();
    const public_key = secret_key.publicKey();
    
    // Use keys...
    const message = "secure message";
    const signature = try secret_key.sign(message, std.heap.page_allocator);
    try public_key.verify(message, &signature);
}
```

### Arena Allocator for Batch Operations

```zig
// src/batch_operations.zig
const std = @import("std");
const gcrypt = @import("gcrypt_zig.zig");

pub fn batchVerifySignatures(
    messages: []const []const u8,
    signatures: []const gcrypt.Ed25519.Signature,
    public_keys: []const gcrypt.Ed25519.PublicKey,
    allocator: std.mem.Allocator,
) !bool {
    if (messages.len != signatures.len or signatures.len != public_keys.len) {
        return error.LengthMismatch;
    }
    
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const arena_allocator = arena.allocator();
    
    // Create temporary storage
    var results = try arena_allocator.alloc(bool, messages.len);
    
    // Verify each signature
    for (messages, signatures, public_keys, 0..) |message, signature, public_key, i| {
        results[i] = public_key.verify(message, &signature) catch false;
    }
    
    // Check all results
    for (results) |result| {
        if (!result) return false;
    }
    
    return true;
}
```

## Error Handling

### Comprehensive Error Handling

```zig
// src/error_handling.zig
const std = @import("std");
const gcrypt = @import("gcrypt_zig.zig");

pub const CryptoError = error{
    InvalidKeyLength,
    InvalidSignatureLength,
    InvalidMessageLength,
    KeyGenerationFailed,
    SigningFailed,
    VerificationFailed,
    KeyExchangeFailed,
    OutOfMemory,
    Unknown,
};

pub fn safeVerifySignature(
    public_key_bytes: []const u8,
    message: []const u8,
    signature_bytes: []const u8,
) CryptoError!bool {
    // Validate input lengths
    if (public_key_bytes.len != 32) {
        return CryptoError.InvalidKeyLength;
    }
    if (signature_bytes.len != 64) {
        return CryptoError.InvalidSignatureLength;
    }
    if (message.len == 0 or message.len > 1024 * 1024) { // 1MB max
        return CryptoError.InvalidMessageLength;
    }
    
    // Convert to fixed-size arrays
    var pk_array: [32]u8 = undefined;
    var sig_array: [64]u8 = undefined;
    
    @memcpy(&pk_array, public_key_bytes);
    @memcpy(&sig_array, signature_bytes);
    
    // Create gcrypt types
    const public_key = gcrypt.Ed25519.PublicKey.fromBytes(pk_array) catch {
        return CryptoError.KeyGenerationFailed;
    };
    const signature = gcrypt.Ed25519.Signature.fromBytes(sig_array);
    
    // Verify signature
    public_key.verify(message, &signature) catch {
        return CryptoError.VerificationFailed;
    };
    
    return true;
}

pub fn safeKeyExchange(
    our_secret_bytes: []const u8,
    their_public_bytes: []const u8,
) CryptoError![32]u8 {
    if (our_secret_bytes.len != 32 or their_public_bytes.len != 32) {
        return CryptoError.InvalidKeyLength;
    }
    
    var secret_array: [32]u8 = undefined;
    var public_array: [32]u8 = undefined;
    
    @memcpy(&secret_array, our_secret_bytes);
    @memcpy(&public_array, their_public_bytes);
    
    const secret_key = gcrypt.X25519.SecretKey.fromBytes(secret_array);
    const public_key = gcrypt.X25519.PublicKey.fromBytes(public_array) catch {
        return CryptoError.KeyGenerationFailed;
    };
    
    var shared_secret = secret_key.exchange(&public_key) catch {
        return CryptoError.KeyExchangeFailed;
    };
    defer shared_secret.deinit();
    
    return shared_secret.toBytes();
}
```

## Performance Tips

### Optimal Build Configuration

```zig
// build.zig additions for performance
pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "gcrypt_optimized",
        .root_source_file = .{ .path = "src/main.zig" },
        .target = target,
        .optimize = optimize,
    });

    // Performance optimizations
    if (optimize == .ReleaseFast or optimize == .ReleaseSmall) {
        exe.strip = true;
        exe.single_threaded = true; // If single-threaded
    }

    // Link optimized gcrypt
    exe.linkLibC();
    exe.addLibraryPath(.{ .path = "target/release" });
    exe.linkSystemLibrary("gcrypt_c");
    exe.addIncludePath(.{ .path = "target/include" });

    // Enable LTO for better optimization
    exe.want_lto = true;

    b.installArtifact(exe);
}
```

### Batch Processing Example

```zig
// src/performance.zig
const std = @import("std");
const gcrypt = @import("gcrypt_zig.zig");

pub fn benchmarkSignatures(count: usize, allocator: std.mem.Allocator) !void {
    std.debug.print("Benchmarking {} signatures...\n", .{count});
    
    // Pre-allocate everything
    var secret_keys = try allocator.alloc(gcrypt.Ed25519.SecretKey, count);
    defer allocator.free(secret_keys);
    
    var public_keys = try allocator.alloc(gcrypt.Ed25519.PublicKey, count);
    defer allocator.free(public_keys);
    
    var signatures = try allocator.alloc(gcrypt.Ed25519.Signature, count);
    defer allocator.free(signatures);
    
    const message = "benchmark message";
    
    // Generate keys
    const start_keygen = std.time.nanoTimestamp();
    for (secret_keys, public_keys) |*secret, *public| {
        secret.* = try gcrypt.Ed25519.SecretKey.generate();
        public.* = secret.publicKey();
    }
    const end_keygen = std.time.nanoTimestamp();
    
    // Sign messages
    const start_sign = std.time.nanoTimestamp();
    for (secret_keys, signatures) |*secret, *signature| {
        signature.* = try secret.sign(message, allocator);
    }
    const end_sign = std.time.nanoTimestamp();
    
    // Verify signatures
    const start_verify = std.time.nanoTimestamp();
    for (public_keys, signatures) |*public, *signature| {
        try public.verify(message, signature);
    }
    const end_verify = std.time.nanoTimestamp();
    
    // Clean up secret keys
    for (secret_keys) |*secret| {
        secret.deinit();
    }
    
    // Report results
    const keygen_ns = end_keygen - start_keygen;
    const sign_ns = end_sign - start_sign;
    const verify_ns = end_verify - start_verify;
    
    std.debug.print("Key generation: {d:.2} µs/op\n", .{@as(f64, @floatFromInt(keygen_ns)) / @as(f64, @floatFromInt(count)) / 1000.0});
    std.debug.print("Signing: {d:.2} µs/op\n", .{@as(f64, @floatFromInt(sign_ns)) / @as(f64, @floatFromInt(count)) / 1000.0});
    std.debug.print("Verification: {d:.2} µs/op\n", .{@as(f64, @floatFromInt(verify_ns)) / @as(f64, @floatFromInt(count)) / 1000.0});
}
```

### Building the Project

1. **Build the Rust library:**
   ```bash
   cargo build --release
   ```

2. **Build the Zig project:**
   ```bash
   zig build -Doptimize=ReleaseFast
   ```

3. **Run the example:**
   ```bash
   zig build run
   ```

This completes the Zig integration guide. The C FFI approach allows Zig projects to leverage gcrypt's performance while maintaining type safety and Zig's memory management patterns.

Good question about attribution! You're right that we should mention curve25519-dalek since we referenced it during development. Let me add that to our documentation.