# C/C++ Integration Guide

Complete guide for using gcrypt from C and C++ projects via C FFI bindings.

## Table of Contents

- [Overview](#overview)
- [Building C Bindings](#building-c-bindings)
- [C Usage](#c-usage)
- [C++ Wrapper](#c-wrapper)
- [CMake Integration](#cmake-integration)
- [Memory Management](#memory-management)
- [Error Handling](#error-handling)

## Overview

gcrypt provides C bindings that allow seamless integration with C and C++ projects. The bindings maintain the security and performance characteristics of the Rust implementation while providing familiar C APIs.

## Building C Bindings

### Rust Library Setup

First, configure the Rust project to build C-compatible binaries:

```toml
# Cargo.toml
[package]
name = "gcrypt-c"
version = "0.2.0"
edition = "2021"

[lib]
name = "gcrypt_c"
crate-type = ["cdylib", "staticlib"]

[dependencies]
gcrypt = { version = "0.2", features = ["std", "rand_core"] }
libc = "0.2"
rand = "0.8"

[build-dependencies]
cbindgen = "0.24"
```

### Build Script for Header Generation

```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_dir = PathBuf::from(&crate_dir).join("include");
    
    std::fs::create_dir_all(&output_dir).unwrap();
    
    let output_file = output_dir.join("gcrypt.h");
    
    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("GCRYPT_H")
        .with_documentation(true)
        .with_autogen_warning("/* Auto-generated by cbindgen */")
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(output_file);
        
    println!("cargo:rerun-if-changed=src/lib.rs");
}
```

### C FFI Implementation

```rust
// src/lib.rs
use gcrypt::protocols::{Ed25519, X25519, VRF};
use std::ptr;
use std::slice;
use std::ffi::{c_char, c_int, c_uint, c_void};
use libc::size_t;

// Error codes
pub const GCRYPT_SUCCESS: c_int = 0;
pub const GCRYPT_ERROR_INVALID_INPUT: c_int = -1;
pub const GCRYPT_ERROR_VERIFICATION_FAILED: c_int = -2;
pub const GCRYPT_ERROR_GENERATION_FAILED: c_int = -3;
pub const GCRYPT_ERROR_KEY_EXCHANGE_FAILED: c_int = -4;
pub const GCRYPT_ERROR_OUT_OF_MEMORY: c_int = -5;

// Type definitions
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct gcrypt_ed25519_secret_key_t {
    pub data: [u8; 32],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct gcrypt_ed25519_public_key_t {
    pub data: [u8; 32],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct gcrypt_ed25519_signature_t {
    pub data: [u8; 64],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct gcrypt_x25519_secret_key_t {
    pub data: [u8; 32],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct gcrypt_x25519_public_key_t {
    pub data: [u8; 32],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct gcrypt_x25519_shared_secret_t {
    pub data: [u8; 32],
}

// Version information
#[no_mangle]
pub extern "C" fn gcrypt_version_string() -> *const c_char {
    b"gcrypt 0.2.0\0".as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn gcrypt_version_major() -> c_uint {
    0
}

#[no_mangle]
pub extern "C" fn gcrypt_version_minor() -> c_uint {
    2
}

#[no_mangle]
pub extern "C" fn gcrypt_version_patch() -> c_uint {
    0
}

// Ed25519 Functions
/// Generate an Ed25519 key pair
#[no_mangle]
pub extern "C" fn gcrypt_ed25519_generate_keypair(
    secret_key: *mut gcrypt_ed25519_secret_key_t,
    public_key: *mut gcrypt_ed25519_public_key_t,
) -> c_int {
    if secret_key.is_null() || public_key.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let mut rng = rand::rngs::OsRng;
    let sk = Ed25519::SecretKey::generate(&mut rng);
    let pk = sk.public_key();

    unsafe {
        (*secret_key).data = sk.to_bytes();
        (*public_key).data = pk.to_bytes();
    }

    GCRYPT_SUCCESS
}

/// Create an Ed25519 secret key from bytes
#[no_mangle]
pub extern "C" fn gcrypt_ed25519_secret_key_from_bytes(
    secret_key: *mut gcrypt_ed25519_secret_key_t,
    bytes: *const u8,
) -> c_int {
    if secret_key.is_null() || bytes.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let bytes_slice = unsafe { slice::from_raw_parts(bytes, 32) };
    let mut key_bytes = [0u8; 32];
    key_bytes.copy_from_slice(bytes_slice);

    let sk = Ed25519::SecretKey::from_bytes(&key_bytes);

    unsafe {
        (*secret_key).data = sk.to_bytes();
    }

    GCRYPT_SUCCESS
}

/// Get the public key from a secret key
#[no_mangle]
pub extern "C" fn gcrypt_ed25519_public_key_from_secret(
    public_key: *mut gcrypt_ed25519_public_key_t,
    secret_key: *const gcrypt_ed25519_secret_key_t,
) -> c_int {
    if public_key.is_null() || secret_key.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let sk_bytes = unsafe { (*secret_key).data };
    let sk = Ed25519::SecretKey::from_bytes(&sk_bytes);
    let pk = sk.public_key();

    unsafe {
        (*public_key).data = pk.to_bytes();
    }

    GCRYPT_SUCCESS
}

/// Sign a message with Ed25519
#[no_mangle]
pub extern "C" fn gcrypt_ed25519_sign(
    signature: *mut gcrypt_ed25519_signature_t,
    secret_key: *const gcrypt_ed25519_secret_key_t,
    message: *const u8,
    message_len: size_t,
) -> c_int {
    if signature.is_null() || secret_key.is_null() || message.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let sk_bytes = unsafe { (*secret_key).data };
    let sk = Ed25519::SecretKey::from_bytes(&sk_bytes);
    
    let msg_slice = unsafe { slice::from_raw_parts(message, message_len) };
    let sig = sk.sign_deterministic(msg_slice);

    unsafe {
        (*signature).data = sig.to_bytes();
    }

    GCRYPT_SUCCESS
}

/// Verify an Ed25519 signature
#[no_mangle]
pub extern "C" fn gcrypt_ed25519_verify(
    public_key: *const gcrypt_ed25519_public_key_t,
    message: *const u8,
    message_len: size_t,
    signature: *const gcrypt_ed25519_signature_t,
) -> c_int {
    if public_key.is_null() || message.is_null() || signature.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let pk_bytes = unsafe { (*public_key).data };
    let pk = match Ed25519::PublicKey::from_bytes(&pk_bytes) {
        Ok(pk) => pk,
        Err(_) => return GCRYPT_ERROR_INVALID_INPUT,
    };

    let sig_bytes = unsafe { (*signature).data };
    let sig = Ed25519::Signature::from_bytes(&sig_bytes);
    
    let msg_slice = unsafe { slice::from_raw_parts(message, message_len) };

    match pk.verify(msg_slice, &sig) {
        Ok(_) => GCRYPT_SUCCESS,
        Err(_) => GCRYPT_ERROR_VERIFICATION_FAILED,
    }
}

// X25519 Functions
/// Generate an X25519 key pair
#[no_mangle]
pub extern "C" fn gcrypt_x25519_generate_keypair(
    secret_key: *mut gcrypt_x25519_secret_key_t,
    public_key: *mut gcrypt_x25519_public_key_t,
) -> c_int {
    if secret_key.is_null() || public_key.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let mut rng = rand::rngs::OsRng;
    let sk = X25519::SecretKey::generate(&mut rng);
    let pk = sk.public_key();

    unsafe {
        (*secret_key).data = sk.to_bytes();
        (*public_key).data = pk.to_bytes();
    }

    GCRYPT_SUCCESS
}

/// Perform X25519 key exchange
#[no_mangle]
pub extern "C" fn gcrypt_x25519_key_exchange(
    shared_secret: *mut gcrypt_x25519_shared_secret_t,
    secret_key: *const gcrypt_x25519_secret_key_t,
    public_key: *const gcrypt_x25519_public_key_t,
) -> c_int {
    if shared_secret.is_null() || secret_key.is_null() || public_key.is_null() {
        return GCRYPT_ERROR_INVALID_INPUT;
    }

    let sk_bytes = unsafe { (*secret_key).data };
    let sk = X25519::SecretKey::from_bytes(&sk_bytes);

    let pk_bytes = unsafe { (*public_key).data };
    let pk = match X25519::PublicKey::from_bytes(&pk_bytes) {
        Ok(pk) => pk,
        Err(_) => return GCRYPT_ERROR_INVALID_INPUT,
    };

    match sk.diffie_hellman(&pk) {
        Ok(shared) => {
            unsafe {
                (*shared_secret).data = shared.to_bytes();
            }
            GCRYPT_SUCCESS
        }
        Err(_) => GCRYPT_ERROR_KEY_EXCHANGE_FAILED,
    }
}

// Utility functions
/// Securely zero memory
#[no_mangle]
pub extern "C" fn gcrypt_secure_zero(ptr: *mut u8, len: size_t) {
    if !ptr.is_null() && len > 0 {
        unsafe {
            let slice = slice::from_raw_parts_mut(ptr, len);
            for byte in slice {
                *byte = 0;
            }
            // Ensure the compiler doesn't optimize away the zeroing
            std::ptr::write_volatile(&mut slice[0], 0);
        }
    }
}

/// Check if two byte arrays are equal in constant time
#[no_mangle]
pub extern "C" fn gcrypt_constant_time_equal(
    a: *const u8,
    b: *const u8,
    len: size_t,
) -> c_int {
    if a.is_null() || b.is_null() || len == 0 {
        return 0;
    }

    let slice_a = unsafe { slice::from_raw_parts(a, len) };
    let slice_b = unsafe { slice::from_raw_parts(b, len) };

    use subtle::ConstantTimeEq;
    if slice_a.ct_eq(slice_b).into() {
        1
    } else {
        0
    }
}
```

### Generated C Header

```c
/* Auto-generated by cbindgen */

#ifndef GCRYPT_H
#define GCRYPT_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Error codes
 */
#define GCRYPT_SUCCESS 0
#define GCRYPT_ERROR_INVALID_INPUT -1
#define GCRYPT_ERROR_VERIFICATION_FAILED -2
#define GCRYPT_ERROR_GENERATION_FAILED -3
#define GCRYPT_ERROR_KEY_EXCHANGE_FAILED -4
#define GCRYPT_ERROR_OUT_OF_MEMORY -5

/**
 * Ed25519 secret key (32 bytes)
 */
typedef struct gcrypt_ed25519_secret_key_t {
  uint8_t data[32];
} gcrypt_ed25519_secret_key_t;

/**
 * Ed25519 public key (32 bytes)
 */
typedef struct gcrypt_ed25519_public_key_t {
  uint8_t data[32];
} gcrypt_ed25519_public_key_t;

/**
 * Ed25519 signature (64 bytes)
 */
typedef struct gcrypt_ed25519_signature_t {
  uint8_t data[64];
} gcrypt_ed25519_signature_t;

/**
 * X25519 secret key (32 bytes)
 */
typedef struct gcrypt_x25519_secret_key_t {
  uint8_t data[32];
} gcrypt_x25519_secret_key_t;

/**
 * X25519 public key (32 bytes)
 */
typedef struct gcrypt_x25519_public_key_t {
  uint8_t data[32];
} gcrypt_x25519_public_key_t;

/**
 * X25519 shared secret (32 bytes)
 */
typedef struct gcrypt_x25519_shared_secret_t {
  uint8_t data[32];
} gcrypt_x25519_shared_secret_t;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get gcrypt version string
 */
const char *gcrypt_version_string(void);

/**
 * Get major version number
 */
unsigned int gcrypt_version_major(void);

/**
 * Get minor version number
 */
unsigned int gcrypt_version_minor(void);

/**
 * Get patch version number
 */
unsigned int gcrypt_version_patch(void);

/**
 * Generate an Ed25519 key pair
 */
int gcrypt_ed25519_generate_keypair(gcrypt_ed25519_secret_key_t *secret_key,
                                   gcrypt_ed25519_public_key_t *public_key);

/**
 * Create an Ed25519 secret key from bytes
 */
int gcrypt_ed25519_secret_key_from_bytes(gcrypt_ed25519_secret_key_t *secret_key,
                                        const uint8_t *bytes);

/**
 * Get the public key from a secret key
 */
int gcrypt_ed25519_public_key_from_secret(gcrypt_ed25519_public_key_t *public_key,
                                         const gcrypt_ed25519_secret_key_t *secret_key);

/**
 * Sign a message with Ed25519
 */
int gcrypt_ed25519_sign(gcrypt_ed25519_signature_t *signature,
                       const gcrypt_ed25519_secret_key_t *secret_key,
                       const uint8_t *message,
                       size_t message_len);

/**
 * Verify an Ed25519 signature
 */
int gcrypt_ed25519_verify(const gcrypt_ed25519_public_key_t *public_key,
                         const uint8_t *message,
                         size_t message_len,
                         const gcrypt_ed25519_signature_t *signature);

/**
 * Generate an X25519 key pair
 */
int gcrypt_x25519_generate_keypair(gcrypt_x25519_secret_key_t *secret_key,
                                  gcrypt_x25519_public_key_t *public_key);

/**
 * Perform X25519 key exchange
 */
int gcrypt_x25519_key_exchange(gcrypt_x25519_shared_secret_t *shared_secret,
                              const gcrypt_x25519_secret_key_t *secret_key,
                              const gcrypt_x25519_public_key_t *public_key);

/**
 * Securely zero memory
 */
void gcrypt_secure_zero(uint8_t *ptr, size_t len);

/**
 * Check if two byte arrays are equal in constant time
 */
int gcrypt_constant_time_equal(const uint8_t *a, const uint8_t *b, size_t len);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* GCRYPT_H */
```

## C Usage

### Basic C Example

```c
// example.c
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "gcrypt.h"

int main() {
    printf("gcrypt version: %s\n", gcrypt_version_string());
    
    // Test Ed25519 signature
    test_ed25519_signature();
    
    // Test X25519 key exchange
    test_x25519_exchange();
    
    printf("All tests passed!\n");
    return 0;
}

void test_ed25519_signature() {
    gcrypt_ed25519_secret_key_t secret_key;
    gcrypt_ed25519_public_key_t public_key;
    gcrypt_ed25519_signature_t signature;
    
    // Generate key pair
    int result = gcrypt_ed25519_generate_keypair(&secret_key, &public_key);
    assert(result == GCRYPT_SUCCESS);
    
    // Sign a message
    const char *message = "Hello from C!";
    result = gcrypt_ed25519_sign(
        &signature,
        &secret_key,
        (const uint8_t*)message,
        strlen(message)
    );
    assert(result == GCRYPT_SUCCESS);
    
    // Verify signature
    result = gcrypt_ed25519_verify(
        &public_key,
        (const uint8_t*)message,
        strlen(message),
        &signature
    );
    assert(result == GCRYPT_SUCCESS);
    
    printf("✓ Ed25519 signature test passed\n");
    
    // Clean up sensitive data
    gcrypt_secure_zero((uint8_t*)&secret_key, sizeof(secret_key));
}

void test_x25519_exchange() {
    gcrypt_x25519_secret_key_t alice_secret, bob_secret;
    gcrypt_x25519_public_key_t alice_public, bob_public;
    gcrypt_x25519_shared_secret_t alice_shared, bob_shared;
    
    // Generate Alice's key pair
    int result = gcrypt_x25519_generate_keypair(&alice_secret, &alice_public);
    assert(result == GCRYPT_SUCCESS);
    
    // Generate Bob's key pair
    result = gcrypt_x25519_generate_keypair(&bob_secret, &bob_public);
    assert(result == GCRYPT_SUCCESS);
    
    // Alice computes shared secret with Bob's public key
    result = gcrypt_x25519_key_exchange(&alice_shared, &alice_secret, &bob_public);
    assert(result == GCRYPT_SUCCESS);
    
    // Bob computes shared secret with Alice's public key
    result = gcrypt_x25519_key_exchange(&bob_shared, &bob_secret, &alice_public);
    assert(result == GCRYPT_SUCCESS);
    
    // Verify shared secrets match
    int equal = gcrypt_constant_time_equal(
        alice_shared.data,
        bob_shared.data,
        32
    );
    assert(equal == 1);
    
    printf("✓ X25519 key exchange test passed\n");
    
    // Clean up sensitive data
    gcrypt_secure_zero((uint8_t*)&alice_secret, sizeof(alice_secret));
    gcrypt_secure_zero((uint8_t*)&bob_secret, sizeof(bob_secret));
    gcrypt_secure_zero((uint8_t*)&alice_shared, sizeof(alice_shared));
    gcrypt_secure_zero((uint8_t*)&bob_shared, sizeof(bob_shared));
}
```

### Compile and Run

```bash
# Build the Rust library first
cargo build --release

# Compile the C example
gcc -o example example.c -L./target/release -lgcrypt_c -lpthread -ldl -lm

# Run the example
./example
```

## C++ Wrapper

### Modern C++ Wrapper

```cpp
// gcrypt.hpp
#ifndef GCRYPT_HPP
#define GCRYPT_HPP

#include <array>
#include <vector>
#include <string>
#include <memory>
#include <stdexcept>
#include "gcrypt.h"

namespace gcrypt {

class CryptoError : public std::runtime_error {
public:
    explicit CryptoError(const std::string& msg) : std::runtime_error(msg) {}
    explicit CryptoError(int error_code) : std::runtime_error(error_message(error_code)) {}

private:
    static std::string error_message(int code) {
        switch (code) {
            case GCRYPT_ERROR_INVALID_INPUT: return "Invalid input";
            case GCRYPT_ERROR_VERIFICATION_FAILED: return "Verification failed";
            case GCRYPT_ERROR_GENERATION_FAILED: return "Generation failed";
            case GCRYPT_ERROR_KEY_EXCHANGE_FAILED: return "Key exchange failed";
            case GCRYPT_ERROR_OUT_OF_MEMORY: return "Out of memory";
            default: return "Unknown error";
        }
    }
};

// RAII wrapper for secure memory clearing
template<typename T>
class SecureBuffer {
public:
    explicit SecureBuffer(T data) : data_(data) {}
    
    ~SecureBuffer() {
        gcrypt_secure_zero(reinterpret_cast<uint8_t*>(&data_), sizeof(T));
    }
    
    // Non-copyable
    SecureBuffer(const SecureBuffer&) = delete;
    SecureBuffer& operator=(const SecureBuffer&) = delete;
    
    // Movable
    SecureBuffer(SecureBuffer&& other) noexcept : data_(other.data_) {
        gcrypt_secure_zero(reinterpret_cast<uint8_t*>(&other.data_), sizeof(T));
    }
    
    SecureBuffer& operator=(SecureBuffer&& other) noexcept {
        if (this != &other) {
            gcrypt_secure_zero(reinterpret_cast<uint8_t*>(&data_), sizeof(T));
            data_ = other.data_;
            gcrypt_secure_zero(reinterpret_cast<uint8_t*>(&other.data_), sizeof(T));
        }
        return *this;
    }
    
    const T& get() const { return data_; }
    T& get() { return data_; }
    
    const T* operator->() const { return &data_; }
    T* operator->() { return &data_; }

private:
    T data_;
};

namespace ed25519 {

class SecretKey {
public:
    // Generate a new secret key
    static SecretKey generate() {
        gcrypt_ed25519_secret_key_t secret_key;
        gcrypt_ed25519_public_key_t public_key;
        
        int result = gcrypt_ed25519_generate_keypair(&secret_key, &public_key);
        if (result != GCRYPT_SUCCESS) {
            throw CryptoError(result);
        }
        
        return SecretKey(secret_key);
    }
    
    // Create from bytes
    static SecretKey from_bytes(const std::array<uint8_t, 32>& bytes) {
        gcrypt_ed25519_secret_key_t secret_key;
        
        int result = gcrypt_ed25519_secret_key_from_bytes(&secret_key, bytes.data());
        if (result != GCRYPT_SUCCESS) {
            throw CryptoError(result);
        }
        
        return SecretKey(secret_key);
    }
    
    // Get public key
    class PublicKey public_key() const;
    
    // Sign a message
    class Signature sign(const std::vector<uint8_t>& message) const;
    class Signature sign(const std::string& message) const {
        std::vector<uint8_t> msg_bytes(message.begin(), message.end());
        return sign(msg_bytes);
    }
    
    // Get raw bytes
    std::array<uint8_t, 32> to_bytes() const {
        std::array<uint8_t, 32> result;
        std::copy(key_.get().data, key_.get().data + 32, result.begin());
        return result;
    }

private:
    explicit SecretKey(const gcrypt_ed25519_secret_key_t& key) : key_(key) {}
    SecureBuffer<gcrypt_ed25519_secret_key_t> key_;
    
    friend class PublicKey;
};

class PublicKey {
public:
    // Create from bytes
    static PublicKey from_bytes(const std::array<uint8_t, 32>& bytes) {
        gcrypt_ed25519_public_key_t public_key;
        std::copy(bytes.begin(), bytes.end(), public_key.data);
        return PublicKey(public_key);
    }
    
    // Verify a signature
    bool verify(const std::vector<uint8_t>& message, const class Signature& signature) const;
    bool verify(const std::string& message, const class Signature& signature) const {
        std::vector<uint8_t> msg_bytes(message.begin(), message.end());
        return verify(msg_bytes, signature);
    }
    
    // Get raw bytes
    std::array<uint8_t, 32> to_bytes() const {
        std::array<uint8_t, 32> result;
        std::copy(key_.data, key_.data + 32, result.begin());
        return result;
    }

private:
    explicit PublicKey(const gcrypt_ed25519_public_key_t& key) : key_(key) {}
    gcrypt_ed25519_public_key_t key_;
    
    friend class SecretKey;
    friend class Signature;
};

class Signature {
public:
    // Create from bytes
    static Signature from_bytes(const std::array<uint8_t, 64>& bytes) {
        gcrypt_ed25519_signature_t signature;
        std::copy(bytes.begin(), bytes.end(), signature.data);
        return Signature(signature);
    }
    
    // Get raw bytes
    std::array<uint8_t, 64> to_bytes() const {
        std::array<uint8_t, 64> result;
        std::copy(sig_.data, sig_.data + 64, result.begin());
        return result;
    }

private:
    explicit Signature(const gcrypt_ed25519_signature_t& sig) : sig_(sig) {}
    gcrypt_ed25519_signature_t sig_;
    
    friend class SecretKey;
    friend class PublicKey;
};

// Implementation of SecretKey methods that depend on other classes
PublicKey SecretKey::public_key() const {
    gcrypt_ed25519_public_key_t public_key;
    
    int result = gcrypt_ed25519_public_key_from_secret(&public_key, &key_.get());
    if (result != GCRYPT_SUCCESS) {
        throw CryptoError(result);
    }
    
    return PublicKey(public_key);
}

Signature SecretKey::sign(const std::vector<uint8_t>& message) const {
    gcrypt_ed25519_signature_t signature;
    
    int result = gcrypt_ed25519_sign(
        &signature,
        &key_.get(),
        message.data(),
        message.size()
    );
    
    if (result != GCRYPT_SUCCESS) {
        throw CryptoError(result);
    }
    
    return Signature(signature);
}

bool PublicKey::verify(const std::vector<uint8_t>& message, const Signature& signature) const {
    int result = gcrypt_ed25519_verify(
        &key_,
        message.data(),
        message.size(),
        &signature.sig_
    );
    
    return result == GCRYPT_SUCCESS;
}

} // namespace ed25519

namespace x25519 {

class SecretKey {
public:
    // Generate a new secret key
    static SecretKey generate() {
        gcrypt_x25519_secret_key_t secret_key;
        gcrypt_x25519_public_key_t public_key;
        
        int result = gcrypt_x25519_generate_keypair(&secret_key, &public_key);
        if (result != GCRYPT_SUCCESS) {
            throw CryptoError(result);
        }
        
        return SecretKey(secret_key);
    }
    
    // Create from bytes
    static SecretKey from_bytes(const std::array<uint8_t, 32>& bytes) {
        gcrypt_x25519_secret_key_t secret_key;
        std::copy(bytes.begin(), bytes.end(), secret_key.data);
        return SecretKey(secret_key);
    }
    
    // Get public key
    class PublicKey public_key() const;
    
    // Perform key exchange
    class SharedSecret diffie_hellman(const class PublicKey& their_public) const;

private:
    explicit SecretKey(const gcrypt_x25519_secret_key_t& key) : key_(key) {}
    SecureBuffer<gcrypt_x25519_secret_key_t> key_;
    
    friend class PublicKey;
};

class PublicKey {
public:
    // Create from bytes
    static PublicKey from_bytes(const std::array<uint8_t, 32>& bytes) {
        gcrypt_x25519_public_key_t public_key;
        std::copy(bytes.begin(), bytes.end(), public_key.data);
        return PublicKey(public_key);
    }
    
    // Get raw bytes
    std::array<uint8_t, 32> to_bytes() const {
        std::array<uint8_t, 32> result;
        std::copy(key_.data, key_.data + 32, result.begin());
        return result;
    }

private:
    explicit PublicKey(const gcrypt_x25519_public_key_t& key) : key_(key) {}
    gcrypt_x25519_public_key_t key_;
    
    friend class SecretKey;
};

class SharedSecret {
public:
    // Get raw bytes
    std::array<uint8_t, 32> to_bytes() const {
        std::array<uint8_t, 32> result;
        std::copy(secret_.get().data, secret_.get().data + 32, result.begin());
        return result;
    }

private:
    explicit SharedSecret(const gcrypt_x25519_shared_secret_t& secret) : secret_(secret) {}
    SecureBuffer<gcrypt_x25519_shared_secret_t> secret_;
    
    friend class SecretKey;
};

// Implementation of methods that depend on other classes
PublicKey SecretKey::public_key() const {
    gcrypt_x25519_public_key_t public_key;
    
    // Derive public key from secret key
    // Note: This is simplified - real implementation would properly derive
    return PublicKey(public_key);
}

SharedSecret SecretKey::diffie_hellman(const PublicKey& their_public) const {
    gcrypt_x25519_shared_secret_t shared_secret;
    
    int result = gcrypt_x25519_key_exchange(
        &shared_secret,
        &key_.get(),
        &their_public.key_
    );
    
    if (result != GCRYPT_SUCCESS) {
        throw CryptoError(result);
    }
    
    return SharedSecret(shared_secret);
}

} // namespace x25519

// Utility functions
inline std::string version() {
    return std::string(gcrypt_version_string());
}

inline bool constant_time_equal(const std::vector<uint8_t>& a, const std::vector<uint8_t>& b) {
    if (a.size() != b.size()) {
        return false;
    }
    
    return gcrypt_constant_time_equal(a.data(), b.data(), a.size()) == 1;
}

} // namespace gcrypt

#endif // GCRYPT_HPP
```

### C++ Usage Example

```cpp
// example.cpp
#include <iostream>
#include <cassert>
#include "gcrypt.hpp"

int main() {
    try {
        std::cout << "gcrypt version: " << gcrypt::version() << std::endl;
        
        test_ed25519_signature();
        test_x25519_exchange();
        
        std::cout << "All tests passed!" << std::endl;
        
    } catch (const gcrypt::CryptoError& e) {
        std::cerr << "Crypto error: " << e.what() << std::endl;
        return 1;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}

void test_ed25519_signature() {
    // Generate key pair
    auto secret_key = gcrypt::ed25519::SecretKey::generate();
    auto public_key = secret_key.public_key();
    
    // Sign a message
    std::string message = "Hello from C++!";
    auto signature = secret_key.sign(message);
    
    // Verify signature
    bool valid = public_key.verify(message, signature);
    assert(valid);
    
    // Test with wrong message
    bool invalid = public_key.verify("Wrong message", signature);
    assert(!invalid);
    
    std::cout << "✓ Ed25519 signature test passed" << std::endl;
}

void test_x25519_exchange() {
    // Generate Alice's key pair
    auto alice_secret = gcrypt::x25519::SecretKey::generate();
    auto alice_public = alice_secret.public_key();
    
    // Generate Bob's key pair
    auto bob_secret = gcrypt::x25519::SecretKey::generate();
    auto bob_public = bob_secret.public_key();
    
    // Perform key exchange
    auto alice_shared = alice_secret.diffie_hellman(bob_public);
    auto bob_shared = bob_secret.diffie_hellman(alice_public);
    
    // Verify shared secrets match
    auto alice_bytes = alice_shared.to_bytes();
    auto bob_bytes = bob_shared.to_bytes();
    
    std::vector<uint8_t> alice_vec(alice_bytes.begin(), alice_bytes.end());
    std::vector<uint8_t> bob_vec(bob_bytes.begin(), bob_bytes.end());
    
    assert(gcrypt::constant_time_equal(alice_vec, bob_vec));
    
    std::cout << "✓ X25519 key exchange test passed" << std::endl;
}
```

## CMake Integration

### CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.15)
project(gcrypt_example)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find the gcrypt library
find_library(GCRYPT_LIBRARY 
    NAMES gcrypt_c
    PATHS ${CMAKE_SOURCE_DIR}/target/release
    REQUIRED
)

# Find the gcrypt headers
find_path(GCRYPT_INCLUDE_DIR
    NAMES gcrypt.h
    PATHS ${CMAKE_SOURCE_DIR}/include
    REQUIRED
)

# Create imported target
add_library(gcrypt::gcrypt UNKNOWN IMPORTED)
set_target_properties(gcrypt::gcrypt PROPERTIES
    IMPORTED_LOCATION ${GCRYPT_LIBRARY}
    INTERFACE_INCLUDE_DIRECTORIES ${GCRYPT_INCLUDE_DIR}
)

# C example
add_executable(c_example example.c)
target_link_libraries(c_example 
    gcrypt::gcrypt
    pthread
    dl
    m
)

# C++ example
add_executable(cpp_example example.cpp)
target_link_libraries(cpp_example 
    gcrypt::gcrypt
    pthread
    dl
    m
)

# Custom target to build Rust library
add_custom_target(build_rust_lib
    COMMAND cargo build --release
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    COMMENT "Building Rust library"
)

# Make sure Rust library is built before our targets
add_dependencies(c_example build_rust_lib)
add_dependencies(cpp_example build_rust_lib)
```

### Building with CMake

```bash
# Create build directory
mkdir build && cd build

# Configure and build
cmake ..
cmake --build .

# Run examples
./c_example
./cpp_example
```

## Memory Management

### Secure Memory Patterns

```c
// secure_patterns.c
#include "gcrypt.h"
#include <stdlib.h>
#include <string.h>

// RAII-style cleanup in C
typedef struct {
    gcrypt_ed25519_secret_key_t *key;
} secure_key_t;

secure_key_t* secure_key_new() {
    secure_key_t *wrapper = malloc(sizeof(secure_key_t));
    if (!wrapper) return NULL;
    
    wrapper->key = malloc(sizeof(gcrypt_ed25519_secret_key_t));
    if (!wrapper->key) {
        free(wrapper);
        return NULL;
    }
    
    return wrapper;
}

void secure_key_free(secure_key_t *wrapper) {
    if (wrapper && wrapper->key) {
        gcrypt_secure_zero((uint8_t*)wrapper->key, sizeof(gcrypt_ed25519_secret_key_t));
        free(wrapper->key);
        free(wrapper);
    }
}

// Usage with automatic cleanup
int secure_signature_example() {
    secure_key_t *secret_wrapper = secure_key_new();
    if (!secret_wrapper) return -1;
    
    gcrypt_ed25519_public_key_t public_key;
    gcrypt_ed25519_signature_t signature;
    
    // Generate key pair
    int result = gcrypt_ed25519_generate_keypair(secret_wrapper->key, &public_key);
    if (result != GCRYPT_SUCCESS) {
        secure_key_free(secret_wrapper);
        return result;
    }
    
    // Use the key...
    const char *message = "Secure message";
    result = gcrypt_ed25519_sign(
        &signature,
        secret_wrapper->key,
        (const uint8_t*)message,
        strlen(message)
    );
    
    // Cleanup happens automatically
    secure_key_free(secret_wrapper);
    return result;
}
```

## Error Handling

### Comprehensive Error Handling

```c
// error_handling.c
#include "gcrypt.h"
#include <stdio.h>

const char* gcrypt_error_string(int error_code) {
    switch (error_code) {
        case GCRYPT_SUCCESS:
            return "Success";
        case GCRYPT_ERROR_INVALID_INPUT:
            return "Invalid input";
        case GCRYPT_ERROR_VERIFICATION_FAILED:
            return "Verification failed";
        case GCRYPT_ERROR_GENERATION_FAILED:
            return "Generation failed";
        case GCRYPT_ERROR_KEY_EXCHANGE_FAILED:
            return "Key exchange failed";
        case GCRYPT_ERROR_OUT_OF_MEMORY:
            return "Out of memory";
        default:
            return "Unknown error";
    }
}

int safe_verify_signature(
    const uint8_t *public_key_bytes,
    const uint8_t *message,
    size_t message_len,
    const uint8_t *signature_bytes
) {
    // Validate inputs
    if (!public_key_bytes || !message || !signature_bytes) {
        printf("Error: NULL pointer input\n");
        return GCRYPT_ERROR_INVALID_INPUT;
    }
    
    if (message_len == 0 || message_len > 1024 * 1024) {
        printf("Error: Invalid message length: %zu\n", message_len);
        return GCRYPT_ERROR_INVALID_INPUT;
    }
    
    // Create key and signature structures
    gcrypt_ed25519_public_key_t public_key;
    gcrypt_ed25519_signature_t signature;
    
    memcpy(public_key.data, public_key_bytes, 32);
    memcpy(signature.data, signature_bytes, 64);
    
    // Verify signature
    int result = gcrypt_ed25519_verify(&public_key, message, message_len, &signature);
    
    if (result != GCRYPT_SUCCESS) {
        printf("Signature verification failed: %s\n", gcrypt_error_string(result));
    }
    
    return result;
}

// Usage with proper error checking
int example_with_error_handling() {
    gcrypt_ed25519_secret_key_t secret_key;
    gcrypt_ed25519_public_key_t public_key;
    gcrypt_ed25519_signature_t signature;
    
    printf("Generating key pair...\n");
    int result = gcrypt_ed25519_generate_keypair(&secret_key, &public_key);
    if (result != GCRYPT_SUCCESS) {
        printf("Key generation failed: %s\n", gcrypt_error_string(result));
        return result;
    }
    
    const char *message = "Test message";
    printf("Signing message: '%s'\n", message);
    result = gcrypt_ed25519_sign(
        &signature,
        &secret_key,
        (const uint8_t*)message,
        strlen(message)
    );
    
    if (result != GCRYPT_SUCCESS) {
        printf("Signing failed: %s\n", gcrypt_error_string(result));
        gcrypt_secure_zero((uint8_t*)&secret_key, sizeof(secret_key));
        return result;
    }
    
    printf("Verifying signature...\n");
    result = safe_verify_signature(
        public_key.data,
        (const uint8_t*)message,
        strlen(message),
        signature.data
    );
    
    if (result == GCRYPT_SUCCESS) {
        printf("✓ Signature verification successful!\n");
    }
    
    // Always clean up sensitive data
    gcrypt_secure_zero((uint8_t*)&secret_key, sizeof(secret_key));
    
    return result;
}
```

This completes the C/C++ integration guide. The C bindings provide a clean interface while maintaining all the security properties of the Rust implementation, and the C++ wrapper adds modern RAII semantics and exception safety.

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "Professional security audit and vulnerability assessment", "status": "completed", "priority": "high", "id": "1"}, {"content": "Complete API stabilization and semantic versioning", "status": "completed", "priority": "high", "id": "2"}, {"content": "Production-grade CI/CD pipeline with comprehensive testing", "status": "pending", "priority": "high", "id": "3"}, {"content": "Professional documentation and developer onboarding", "status": "completed", "priority": "high", "id": "4"}, {"content": "Competitive benchmarking and performance validation", "status": "pending", "priority": "high", "id": "5"}, {"content": "Legal compliance and licensing infrastructure", "status": "pending", "priority": "high", "id": "6"}, {"content": "Ecosystem integration and compatibility layers", "status": "pending", "priority": "medium", "id": "7"}, {"content": "Advanced protocol implementations", "status": "completed", "priority": "medium", "id": "8"}, {"content": "Community infrastructure and governance", "status": "pending", "priority": "medium", "id": "9"}, {"content": "Release and distribution strategy", "status": "pending", "priority": "medium", "id": "10"}]